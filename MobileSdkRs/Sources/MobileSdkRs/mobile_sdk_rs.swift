// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(mobile_sdk_rsFFI)
import mobile_sdk_rsFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_mobile_sdk_rs_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_mobile_sdk_rs_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol AsyncHttpClient : AnyObject {
    
    func httpClient(request: HttpRequest) async throws  -> HttpResponse
    
}

open class AsyncHttpClientImpl:
    AsyncHttpClient {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_asynchttpclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_asynchttpclient(pointer, $0) }
    }

    

    
open func httpClient(request: HttpRequest)async throws  -> HttpResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_asynchttpclient_http_client(
                    self.uniffiClonePointer(),
                    FfiConverterTypeHttpRequest.lower(request)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeHttpResponse.lift,
            errorHandler: FfiConverterTypeHttpClientError.lift
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceAsyncHttpClient {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceAsyncHttpClient = UniffiVTableCallbackInterfaceAsyncHttpClient(
        httpClient: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> HttpResponse in
                guard let uniffiObj = try? FfiConverterTypeAsyncHttpClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.httpClient(
                     request: try FfiConverterTypeHttpRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: HttpResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeHttpResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeHttpClientError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeAsyncHttpClient.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface AsyncHttpClient: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitAsyncHttpClient() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_asynchttpclient(&UniffiCallbackInterfaceAsyncHttpClient.vtable)
}

public struct FfiConverterTypeAsyncHttpClient: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<AsyncHttpClient>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AsyncHttpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AsyncHttpClient {
        return AsyncHttpClientImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AsyncHttpClient) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AsyncHttpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AsyncHttpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeAsyncHttpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> AsyncHttpClient {
    return try FfiConverterTypeAsyncHttpClient.lift(pointer)
}

public func FfiConverterTypeAsyncHttpClient_lower(_ value: AsyncHttpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAsyncHttpClient.lower(value)
}




public protocol ClientProtocol : AnyObject {
    
}

open class Client:
    ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_client(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_client(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}




public protocol CredentialIssuerMetadataProtocol : AnyObject {
    
}

open class CredentialIssuerMetadata:
    CredentialIssuerMetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_credentialissuermetadata(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_credentialissuermetadata(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeCredentialIssuerMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CredentialIssuerMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CredentialIssuerMetadata {
        return CredentialIssuerMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CredentialIssuerMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialIssuerMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CredentialIssuerMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeCredentialIssuerMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> CredentialIssuerMetadata {
    return try FfiConverterTypeCredentialIssuerMetadata.lift(pointer)
}

public func FfiConverterTypeCredentialIssuerMetadata_lower(_ value: CredentialIssuerMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCredentialIssuerMetadata.lower(value)
}




public protocol CredentialRequestProtocol : AnyObject {
    
}

open class CredentialRequest:
    CredentialRequestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_credentialrequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_credentialrequest(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeCredentialRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CredentialRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CredentialRequest {
        return CredentialRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CredentialRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CredentialRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeCredentialRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> CredentialRequest {
    return try FfiConverterTypeCredentialRequest.lift(pointer)
}

public func FfiConverterTypeCredentialRequest_lower(_ value: CredentialRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCredentialRequest.lower(value)
}




public protocol DelegatedVerifierProtocol : AnyObject {
    
    func pollVerificationStatus(url: String) async throws  -> DelegatedVerifierStatusResponse
    
    /**
     * Initialize a delegated verification request.
     *
     * This method will respond with a uniffi::Record object that contains the
     * `auth_query` to be presented via QR code to the holder, and a `uri` to
     * check the status of the presentation from the delegated verifier.
     *
     * Provide the `uri` to the [Verifier::poll_verification_status] method to
     * check the status of the presentation.
     */
    func requestDelegatedVerification(url: String) async throws  -> DelegateInitializationResponse
    
}

open class DelegatedVerifier:
    DelegatedVerifierProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_delegatedverifier(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_delegatedverifier(pointer, $0) }
    }

    
public static func newClient(baseUrl: Url)async throws  -> DelegatedVerifier {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_constructor_delegatedverifier_new_client(FfiConverterTypeUrl.lower(baseUrl)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeDelegatedVerifier.lift,
            errorHandler: FfiConverterTypeOid4vpVerifierError.lift
        )
}
    

    
open func pollVerificationStatus(url: String)async throws  -> DelegatedVerifierStatusResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_delegatedverifier_poll_verification_status(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeDelegatedVerifierStatusResponse.lift,
            errorHandler: FfiConverterTypeOid4vpVerifierError.lift
        )
}
    
    /**
     * Initialize a delegated verification request.
     *
     * This method will respond with a uniffi::Record object that contains the
     * `auth_query` to be presented via QR code to the holder, and a `uri` to
     * check the status of the presentation from the delegated verifier.
     *
     * Provide the `uri` to the [Verifier::poll_verification_status] method to
     * check the status of the presentation.
     */
open func requestDelegatedVerification(url: String)async throws  -> DelegateInitializationResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_delegatedverifier_request_delegated_verification(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeDelegateInitializationResponse.lift,
            errorHandler: FfiConverterTypeOid4vpVerifierError.lift
        )
}
    

}

public struct FfiConverterTypeDelegatedVerifier: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DelegatedVerifier

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DelegatedVerifier {
        return DelegatedVerifier(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DelegatedVerifier) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DelegatedVerifier {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DelegatedVerifier, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeDelegatedVerifier_lift(_ pointer: UnsafeMutableRawPointer) throws -> DelegatedVerifier {
    return try FfiConverterTypeDelegatedVerifier.lift(pointer)
}

public func FfiConverterTypeDelegatedVerifier_lower(_ value: DelegatedVerifier) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDelegatedVerifier.lower(value)
}




public protocol DidMethodUtilsProtocol : AnyObject {
    
    func didFromJwk(jwk: String) throws  -> String
    
    func vmFromJwk(jwk: String) async throws  -> String
    
}

open class DidMethodUtils:
    DidMethodUtilsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_didmethodutils(self.pointer, $0) }
    }
public convenience init(method: DidMethod) {
    let pointer =
        try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_didmethodutils_new(
        FfiConverterTypeDidMethod.lower(method),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_didmethodutils(pointer, $0) }
    }

    

    
open func didFromJwk(jwk: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeDidError.lift) {
    uniffi_mobile_sdk_rs_fn_method_didmethodutils_did_from_jwk(self.uniffiClonePointer(),
        FfiConverterString.lower(jwk),$0
    )
})
}
    
open func vmFromJwk(jwk: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_didmethodutils_vm_from_jwk(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(jwk)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeDidError.lift
        )
}
    

}

public struct FfiConverterTypeDidMethodUtils: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DidMethodUtils

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DidMethodUtils {
        return DidMethodUtils(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DidMethodUtils) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DidMethodUtils {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DidMethodUtils, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeDidMethodUtils_lift(_ pointer: UnsafeMutableRawPointer) throws -> DidMethodUtils {
    return try FfiConverterTypeDidMethodUtils.lift(pointer)
}

public func FfiConverterTypeDidMethodUtils_lower(_ value: DidMethodUtils) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDidMethodUtils.lower(value)
}




public protocol GrantsProtocol : AnyObject {
    
}

open class Grants:
    GrantsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_grants(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_grants(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeGrants: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Grants

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Grants {
        return Grants(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Grants) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Grants {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Grants, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeGrants_lift(_ pointer: UnsafeMutableRawPointer) throws -> Grants {
    return try FfiConverterTypeGrants.lift(pointer)
}

public func FfiConverterTypeGrants_lower(_ value: Grants) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGrants.lower(value)
}




/**
 * A Holder is an entity that possesses one or more Verifiable Credentials.
 * The Holder is typically the subject of the credentials, but not always.
 * The Holder has the ability to generate Verifiable Presentations from
 * these credentials and share them with Verifiers.
 */
public protocol HolderProtocol : AnyObject {
    
    /**
     * Given an authorization request URL, return a permission request,
     * which provides a list of requested credentials and requested fields
     * that align with the presentation definition of the request.
     *
     * This will fetch the presentation definition from the verifier.
     */
    func authorizationRequest(url: Url) async throws  -> PermissionRequest
    
    func submitPermissionResponse(response: PermissionResponse) async throws  -> Url?
    
}

/**
 * A Holder is an entity that possesses one or more Verifiable Credentials.
 * The Holder is typically the subject of the credentials, but not always.
 * The Holder has the ability to generate Verifiable Presentations from
 * these credentials and share them with Verifiers.
 */
open class Holder:
    HolderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_holder(self.pointer, $0) }
    }
    /**
     * Uses VDC collection to retrieve the credentials for a given presentation definition.
     */
public convenience init(vdcCollection: VdcCollection, trustedDids: [String], signer: PresentationSigner, contextMap: [String: String]?)async throws  {
    let pointer =
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_constructor_holder_new(FfiConverterTypeVdcCollection.lower(vdcCollection),FfiConverterSequenceString.lower(trustedDids),FfiConverterCallbackInterfacePresentationSigner.lower(signer),FfiConverterOptionDictionaryStringString.lower(contextMap)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeHolder.lift,
            errorHandler: FfiConverterTypeOID4VPError.lift
        )
        
        .uniffiClonePointer()
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_holder(pointer, $0) }
    }

    
    /**
     * Construct a new holder with provided credentials
     * instead of a VDC collection.
     *
     * This constructor will use the provided credentials for the presentation,
     * instead of searching for credentials in the VDC collection.
     */
public static func newWithCredentials(providedCredentials: [ParsedCredential], trustedDids: [String], signer: PresentationSigner, contextMap: [String: String]?)async throws  -> Holder {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_constructor_holder_new_with_credentials(FfiConverterSequenceTypeParsedCredential.lower(providedCredentials),FfiConverterSequenceString.lower(trustedDids),FfiConverterCallbackInterfacePresentationSigner.lower(signer),FfiConverterOptionDictionaryStringString.lower(contextMap)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeHolder.lift,
            errorHandler: FfiConverterTypeOID4VPError.lift
        )
}
    

    
    /**
     * Given an authorization request URL, return a permission request,
     * which provides a list of requested credentials and requested fields
     * that align with the presentation definition of the request.
     *
     * This will fetch the presentation definition from the verifier.
     */
open func authorizationRequest(url: Url)async throws  -> PermissionRequest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_holder_authorization_request(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUrl.lower(url)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypePermissionRequest.lift,
            errorHandler: FfiConverterTypeOID4VPError.lift
        )
}
    
open func submitPermissionResponse(response: PermissionResponse)async throws  -> Url? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_holder_submit_permission_response(
                    self.uniffiClonePointer(),
                    FfiConverterTypePermissionResponse.lower(response)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeUrl.lift,
            errorHandler: FfiConverterTypeOID4VPError.lift
        )
}
    

}

public struct FfiConverterTypeHolder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Holder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Holder {
        return Holder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Holder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Holder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Holder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeHolder_lift(_ pointer: UnsafeMutableRawPointer) throws -> Holder {
    return try FfiConverterTypeHolder.lift(pointer)
}

public func FfiConverterTypeHolder_lower(_ value: Holder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHolder.lower(value)
}




/**
 * Http client wrapper type that could either be a synchronous or asynchronous
 * external (Kotlin, Swift, etc) client implementation, receveid as a dynamic
 * trait implementation reference (`Arc<dyn (As|S)yncHttpClient`).
 *
 * `Arc` is wrapped with `IArc` to facilitate trait implementation from
 * `openidconnect` library used by request builders and client on `oid4vci-rs`.
 */
public protocol IHttpClientProtocol : AnyObject {
    
}

/**
 * Http client wrapper type that could either be a synchronous or asynchronous
 * external (Kotlin, Swift, etc) client implementation, receveid as a dynamic
 * trait implementation reference (`Arc<dyn (As|S)yncHttpClient`).
 *
 * `Arc` is wrapped with `IArc` to facilitate trait implementation from
 * `openidconnect` library used by request builders and client on `oid4vci-rs`.
 */
open class IHttpClient:
    IHttpClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_ihttpclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_ihttpclient(pointer, $0) }
    }

    
public static func newAsync(clientImpl: AsyncHttpClient) -> IHttpClient {
    return try!  FfiConverterTypeIHttpClient.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_ihttpclient_new_async(
        FfiConverterTypeAsyncHttpClient.lower(clientImpl),$0
    )
})
}
    
public static func newSync(clientImpl: SyncHttpClient) -> IHttpClient {
    return try!  FfiConverterTypeIHttpClient.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_ihttpclient_new_sync(
        FfiConverterTypeSyncHttpClient.lower(clientImpl),$0
    )
})
}
    

    

}

public struct FfiConverterTypeIHttpClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = IHttpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> IHttpClient {
        return IHttpClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: IHttpClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IHttpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: IHttpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeIHttpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> IHttpClient {
    return try FfiConverterTypeIHttpClient.lift(pointer)
}

public func FfiConverterTypeIHttpClient_lower(_ value: IHttpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIHttpClient.lower(value)
}




public protocol InProcessRecordProtocol : AnyObject {
    
}

open class InProcessRecord:
    InProcessRecordProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_inprocessrecord(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_inprocessrecord(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeInProcessRecord: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = InProcessRecord

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> InProcessRecord {
        return InProcessRecord(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: InProcessRecord) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InProcessRecord {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: InProcessRecord, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeInProcessRecord_lift(_ pointer: UnsafeMutableRawPointer) throws -> InProcessRecord {
    return try FfiConverterTypeInProcessRecord.lift(pointer)
}

public func FfiConverterTypeInProcessRecord_lower(_ value: InProcessRecord) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInProcessRecord.lower(value)
}




/**
 * A verifiable credential secured as JSON.
 */
public protocol JsonVcProtocol : AnyObject {
    
    /**
     * Access the W3C VCDM credential as a JSON encoded UTF-8 string.
     */
    func credentialAsJsonEncodedUtf8String()  -> String
    
    /**
     * The local ID of this credential.
     */
    func id()  -> Uuid
    
    /**
     * The keypair identified in the credential for use in a verifiable presentation.
     */
    func keyAlias()  -> KeyAlias?
    
    /**
     * Returns the status of the credential, resolving the value in the status list,
     * along with the purpose of the status.
     */
    func status() async throws  -> Status
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
    func type()  -> CredentialType
    
    /**
     * The types of the credential from the VCDM, excluding the base `VerifiableCredential` type.
     */
    func types()  -> [String]
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
    func vcdmVersion()  -> VcdmVersion
    
}

/**
 * A verifiable credential secured as JSON.
 */
open class JsonVc:
    JsonVcProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_jsonvc(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_jsonvc(pointer, $0) }
    }

    
    /**
     * Construct a new credential from UTF-8 encoded JSON.
     */
public static func newFromJson(utf8JsonString: String)throws  -> JsonVc {
    return try  FfiConverterTypeJsonVc.lift(try rustCallWithError(FfiConverterTypeJsonVcInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_jsonvc_new_from_json(
        FfiConverterString.lower(utf8JsonString),$0
    )
})
}
    
    /**
     * Construct a new credential from UTF-8 encoded JSON.
     */
public static func newFromJsonWithKey(utf8JsonString: String, keyAlias: KeyAlias)throws  -> JsonVc {
    return try  FfiConverterTypeJsonVc.lift(try rustCallWithError(FfiConverterTypeJsonVcInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_jsonvc_new_from_json_with_key(
        FfiConverterString.lower(utf8JsonString),
        FfiConverterTypeKeyAlias.lower(keyAlias),$0
    )
})
}
    

    
    /**
     * Access the W3C VCDM credential as a JSON encoded UTF-8 string.
     */
open func credentialAsJsonEncodedUtf8String() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_credential_as_json_encoded_utf8_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The local ID of this credential.
     */
open func id() -> Uuid {
    return try!  FfiConverterTypeUuid.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The keypair identified in the credential for use in a verifiable presentation.
     */
open func keyAlias() -> KeyAlias? {
    return try!  FfiConverterOptionTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the status of the credential, resolving the value in the status list,
     * along with the purpose of the status.
     */
open func status()async throws  -> Status {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_jsonvc_status(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeStatus.lift,
            errorHandler: FfiConverterTypeStatusListError.lift
        )
}
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
open func type() -> CredentialType {
    return try!  FfiConverterTypeCredentialType.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_type(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The types of the credential from the VCDM, excluding the base `VerifiableCredential` type.
     */
open func types() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_types(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
open func vcdmVersion() -> VcdmVersion {
    return try!  FfiConverterTypeVcdmVersion.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_vcdm_version(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeJsonVc: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = JsonVc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> JsonVc {
        return JsonVc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: JsonVc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonVc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: JsonVc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeJsonVc_lift(_ pointer: UnsafeMutableRawPointer) throws -> JsonVc {
    return try FfiConverterTypeJsonVc.lift(pointer)
}

public func FfiConverterTypeJsonVc_lower(_ value: JsonVc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeJsonVc.lower(value)
}




/**
 * A verifiable credential secured as a JWT.
 */
public protocol JwtVcProtocol : AnyObject {
    
    /**
     * Access the W3C VCDM credential as a JSON encoded UTF-8 string.
     */
    func credentialAsJsonEncodedUtf8String()  -> String
    
    /**
     * The VdcCollection ID for this credential.
     */
    func id()  -> Uuid
    
    /**
     * Access the JWS header as a JSON encoded UTF-8 string.
     */
    func jwsHeaderAsJsonEncodedUtf8String()  -> String
    
    /**
     * Access the JWS payload as a JSON encoded UTF-8 string.
     */
    func jwsPayloadAsJsonEncodedUtf8String()  -> String
    
    /**
     * The keypair identified in the credential for use in a verifiable presentation.
     */
    func keyAlias()  -> KeyAlias?
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
    func type()  -> CredentialType
    
    /**
     * The types of the credential from the VCDM, excluding the base `VerifiableCredential` type.
     */
    func types()  -> [String]
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
    func vcdmVersion()  -> VcdmVersion
    
}

/**
 * A verifiable credential secured as a JWT.
 */
open class JwtVc:
    JwtVcProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_jwtvc(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_jwtvc(pointer, $0) }
    }

    
    /**
     * Construct a new credential from a compact JWS (of the form
     * `<base64-encoded-header>.<base64-encoded-payload>.<base64-encoded-signature>`),
     * without an associated keypair.
     */
public static func newFromCompactJws(jws: String)throws  -> JwtVc {
    return try  FfiConverterTypeJwtVc.lift(try rustCallWithError(FfiConverterTypeJwtVcInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_jwtvc_new_from_compact_jws(
        FfiConverterString.lower(jws),$0
    )
})
}
    
    /**
     * Construct a new credential from a compact JWS (of the form
     * `<base64-encoded-header>.<base64-encoded-payload>.<base64-encoded-signature>`),
     * with an associated keypair.
     */
public static func newFromCompactJwsWithKey(jws: String, keyAlias: KeyAlias)throws  -> JwtVc {
    return try  FfiConverterTypeJwtVc.lift(try rustCallWithError(FfiConverterTypeJwtVcInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_jwtvc_new_from_compact_jws_with_key(
        FfiConverterString.lower(jws),
        FfiConverterTypeKeyAlias.lower(keyAlias),$0
    )
})
}
    

    
    /**
     * Access the W3C VCDM credential as a JSON encoded UTF-8 string.
     */
open func credentialAsJsonEncodedUtf8String() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_credential_as_json_encoded_utf8_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The VdcCollection ID for this credential.
     */
open func id() -> Uuid {
    return try!  FfiConverterTypeUuid.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Access the JWS header as a JSON encoded UTF-8 string.
     */
open func jwsHeaderAsJsonEncodedUtf8String() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_jws_header_as_json_encoded_utf8_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Access the JWS payload as a JSON encoded UTF-8 string.
     */
open func jwsPayloadAsJsonEncodedUtf8String() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_jws_payload_as_json_encoded_utf8_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The keypair identified in the credential for use in a verifiable presentation.
     */
open func keyAlias() -> KeyAlias? {
    return try!  FfiConverterOptionTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
open func type() -> CredentialType {
    return try!  FfiConverterTypeCredentialType.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_type(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The types of the credential from the VCDM, excluding the base `VerifiableCredential` type.
     */
open func types() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_types(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
open func vcdmVersion() -> VcdmVersion {
    return try!  FfiConverterTypeVcdmVersion.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_vcdm_version(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeJwtVc: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = JwtVc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> JwtVc {
        return JwtVc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: JwtVc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JwtVc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: JwtVc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeJwtVc_lift(_ pointer: UnsafeMutableRawPointer) throws -> JwtVc {
    return try FfiConverterTypeJwtVc.lift(pointer)
}

public func FfiConverterTypeJwtVc_lower(_ value: JwtVc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeJwtVc.lower(value)
}




public protocol MdlSessionManagerProtocol : AnyObject {
    
}

open class MdlSessionManager:
    MdlSessionManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_mdlsessionmanager(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_mdlsessionmanager(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeMDLSessionManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MdlSessionManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MdlSessionManager {
        return MdlSessionManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MdlSessionManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlSessionManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MdlSessionManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMDLSessionManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> MdlSessionManager {
    return try FfiConverterTypeMDLSessionManager.lift(pointer)
}

public func FfiConverterTypeMDLSessionManager_lower(_ value: MdlSessionManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMDLSessionManager.lower(value)
}




public protocol MdlPresentationSessionProtocol : AnyObject {
    
    /**
     * Constructs the response to be sent from the holder to the reader containing
     * the items of information the user has consented to share.
     *
     * Takes a HashMap of items the user has authorized the app to share, as well
     * as the id of a key stored in the key manager to be used to sign the response.
     * Returns a byte array containing the signed response to be returned to the
     * reader.
     */
    func generateResponse(permittedItems: [String: [String: [String]]]) throws  -> Data
    
    /**
     * Returns the BLE identification
     */
    func getBleIdent()  -> Data
    
    /**
     * Returns the generated QR code
     */
    func getQrCodeUri()  -> String
    
    /**
     * Handle a request from a reader that is seeking information from the mDL holder.
     *
     * Takes the raw bytes received from the reader by the holder over the transmission
     * technology. Returns a Vector of information items requested by the reader, or an
     * error.
     */
    func handleRequest(request: Data) throws  -> [ItemsRequest]
    
    func submitResponse(derSignature: Data) throws  -> Data
    
    /**
     * Terminates the mDL exchange session.
     *
     * Returns the termination message to be transmitted to the reader.
     */
    func terminateSession() throws  -> Data
    
}

open class MdlPresentationSession:
    MdlPresentationSessionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_mdlpresentationsession(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_mdlpresentationsession(pointer, $0) }
    }

    

    
    /**
     * Constructs the response to be sent from the holder to the reader containing
     * the items of information the user has consented to share.
     *
     * Takes a HashMap of items the user has authorized the app to share, as well
     * as the id of a key stored in the key manager to be used to sign the response.
     * Returns a byte array containing the signed response to be returned to the
     * reader.
     */
open func generateResponse(permittedItems: [String: [String: [String]]])throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSignatureError.lift) {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_generate_response(self.uniffiClonePointer(),
        FfiConverterDictionaryStringDictionaryStringSequenceString.lower(permittedItems),$0
    )
})
}
    
    /**
     * Returns the BLE identification
     */
open func getBleIdent() -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_get_ble_ident(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the generated QR code
     */
open func getQrCodeUri() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_get_qr_code_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Handle a request from a reader that is seeking information from the mDL holder.
     *
     * Takes the raw bytes received from the reader by the holder over the transmission
     * technology. Returns a Vector of information items requested by the reader, or an
     * error.
     */
open func handleRequest(request: Data)throws  -> [ItemsRequest] {
    return try  FfiConverterSequenceTypeItemsRequest.lift(try rustCallWithError(FfiConverterTypeRequestError.lift) {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_handle_request(self.uniffiClonePointer(),
        FfiConverterData.lower(request),$0
    )
})
}
    
open func submitResponse(derSignature: Data)throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSignatureError.lift) {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_submit_response(self.uniffiClonePointer(),
        FfiConverterData.lower(derSignature),$0
    )
})
}
    
    /**
     * Terminates the mDL exchange session.
     *
     * Returns the termination message to be transmitted to the reader.
     */
open func terminateSession()throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeTerminationError.lift) {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_terminate_session(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeMdlPresentationSession: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MdlPresentationSession

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MdlPresentationSession {
        return MdlPresentationSession(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MdlPresentationSession) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlPresentationSession {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MdlPresentationSession, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMdlPresentationSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> MdlPresentationSession {
    return try FfiConverterTypeMdlPresentationSession.lift(pointer)
}

public func FfiConverterTypeMdlPresentationSession_lower(_ value: MdlPresentationSession) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMdlPresentationSession.lower(value)
}




public protocol MdocProtocol : AnyObject {
    
    /**
     * Simple representation of mdoc namespace and data elements for display in the UI.
     */
    func details()  -> [Namespace: [Element]]
    
    /**
     * The document type of this mdoc, for example `org.iso.18013.5.1.mDL`.
     */
    func doctype()  -> String
    
    /**
     * The local ID of this credential.
     */
    func id()  -> Uuid
    
    func keyAlias()  -> KeyAlias
    
}

open class Mdoc:
    MdocProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_mdoc(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_mdoc(pointer, $0) }
    }

    
    /**
     * Construct a SpruceKit MDoc from a cbor-encoded
     * [spruceid/isomdl `Document`](https://github.com/spruceid/isomdl/blob/main/src/presentation/device.rs#L145-L152)
     */
public static func fromCborEncodedDocument(cborEncodedDocument: Data, keyAlias: KeyAlias)throws  -> Mdoc {
    return try  FfiConverterTypeMdoc.lift(try rustCallWithError(FfiConverterTypeMdocInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_mdoc_from_cbor_encoded_document(
        FfiConverterData.lower(cborEncodedDocument),
        FfiConverterTypeKeyAlias.lower(keyAlias),$0
    )
})
}
    
    /**
     * Compatibility feature: construct an MDoc from a
     * [stringified spruceid/isomdl `Document`](https://github.com/spruceid/isomdl/blob/main/src/presentation/mod.rs#L100)
     */
public static func fromStringifiedDocument(stringifiedDocument: String, keyAlias: KeyAlias)throws  -> Mdoc {
    return try  FfiConverterTypeMdoc.lift(try rustCallWithError(FfiConverterTypeMdocInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_mdoc_from_stringified_document(
        FfiConverterString.lower(stringifiedDocument),
        FfiConverterTypeKeyAlias.lower(keyAlias),$0
    )
})
}
    
    /**
     * Construct a new MDoc from base64url-encoded IssuerSigned.
     */
public static func newFromBase64urlEncodedIssuerSigned(base64urlEncodedIssuerSigned: String, keyAlias: KeyAlias)throws  -> Mdoc {
    return try  FfiConverterTypeMdoc.lift(try rustCallWithError(FfiConverterTypeMdocInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_mdoc_new_from_base64url_encoded_issuer_signed(
        FfiConverterString.lower(base64urlEncodedIssuerSigned),
        FfiConverterTypeKeyAlias.lower(keyAlias),$0
    )
})
}
    

    
    /**
     * Simple representation of mdoc namespace and data elements for display in the UI.
     */
open func details() -> [Namespace: [Element]] {
    return try!  FfiConverterDictionaryTypeNamespaceSequenceTypeElement.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdoc_details(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The document type of this mdoc, for example `org.iso.18013.5.1.mDL`.
     */
open func doctype() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdoc_doctype(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The local ID of this credential.
     */
open func id() -> Uuid {
    return try!  FfiConverterTypeUuid.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdoc_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func keyAlias() -> KeyAlias {
    return try!  FfiConverterTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdoc_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeMdoc: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Mdoc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Mdoc {
        return Mdoc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Mdoc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mdoc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Mdoc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMdoc_lift(_ pointer: UnsafeMutableRawPointer) throws -> Mdoc {
    return try FfiConverterTypeMdoc.lift(pointer)
}

public func FfiConverterTypeMdoc_lower(_ value: Mdoc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMdoc.lower(value)
}




public protocol Oid4vciProtocol : AnyObject {
    
    func clearContextMap() throws 
    
    func exchangeCredential(proofsOfPossession: [String]) async throws  -> [CredentialResponse]
    
    func exchangeToken() async throws  -> String?
    
    func getMetadata() throws  -> Oid4vciMetadata
    
    func initiate(baseUrl: String, clientId: String, redirectUrl: String) async throws 
    
    func initiateLogger() 
    
    func initiateWithOffer(credentialOffer: String, clientId: String, redirectUrl: String) async throws 
    
    func setContextMap(values: [String: String]) throws 
    
}

open class Oid4vci:
    Oid4vciProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_oid4vci(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_oid4vci(pointer, $0) }
    }

    
public static func newWithAsyncClient(client: AsyncHttpClient) -> Oid4vci {
    return try!  FfiConverterTypeOid4vci.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new_with_async_client(
        FfiConverterTypeAsyncHttpClient.lower(client),$0
    )
})
}
    
public static func newWithDefaultAsyncClient() -> Oid4vci {
    return try!  FfiConverterTypeOid4vci.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new_with_default_async_client($0
    )
})
}
    
public static func newWithDefaultSyncClient() -> Oid4vci {
    return try!  FfiConverterTypeOid4vci.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new_with_default_sync_client($0
    )
})
}
    
public static func newWithSyncClient(client: SyncHttpClient) -> Oid4vci {
    return try!  FfiConverterTypeOid4vci.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new_with_sync_client(
        FfiConverterTypeSyncHttpClient.lower(client),$0
    )
})
}
    

    
open func clearContextMap()throws  {try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_method_oid4vci_clear_context_map(self.uniffiClonePointer(),$0
    )
}
}
    
open func exchangeCredential(proofsOfPossession: [String])async throws  -> [CredentialResponse] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vci_exchange_credential(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(proofsOfPossession)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeCredentialResponse.lift,
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
    
open func exchangeToken()async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vci_exchange_token(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
    
open func getMetadata()throws  -> Oid4vciMetadata {
    return try  FfiConverterTypeOid4vciMetadata.lift(try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_method_oid4vci_get_metadata(self.uniffiClonePointer(),$0
    )
})
}
    
open func initiate(baseUrl: String, clientId: String, redirectUrl: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vci_initiate(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(baseUrl),FfiConverterString.lower(clientId),FfiConverterString.lower(redirectUrl)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
    
open func initiateLogger() {try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vci_initiate_logger(self.uniffiClonePointer(),$0
    )
}
}
    
open func initiateWithOffer(credentialOffer: String, clientId: String, redirectUrl: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vci_initiate_with_offer(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(credentialOffer),FfiConverterString.lower(clientId),FfiConverterString.lower(redirectUrl)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
    
open func setContextMap(values: [String: String])throws  {try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_method_oid4vci_set_context_map(self.uniffiClonePointer(),
        FfiConverterDictionaryStringString.lower(values),$0
    )
}
}
    

}

public struct FfiConverterTypeOid4vci: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Oid4vci

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vci {
        return Oid4vci(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Oid4vci) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vci {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Oid4vci, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOid4vci_lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vci {
    return try FfiConverterTypeOid4vci.lift(pointer)
}

public func FfiConverterTypeOid4vci_lower(_ value: Oid4vci) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOid4vci.lower(value)
}




public protocol Oid4vciMetadataProtocol : AnyObject {
    
    func authorizationServers()  -> [String]?
    
    func batchCredentialEndpoint()  -> String?
    
    func credentialEndpoint()  -> String
    
    func deferredCredentialEndpoint()  -> String?
    
    func issuer()  -> String
    
    func notificationEndpoint()  -> String?
    
    func toJson() throws  -> String
    
}

open class Oid4vciMetadata:
    Oid4vciMetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_oid4vcimetadata(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_oid4vcimetadata(pointer, $0) }
    }

    

    
open func authorizationServers() -> [String]? {
    return try!  FfiConverterOptionSequenceString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_authorization_servers(self.uniffiClonePointer(),$0
    )
})
}
    
open func batchCredentialEndpoint() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_batch_credential_endpoint(self.uniffiClonePointer(),$0
    )
})
}
    
open func credentialEndpoint() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_credential_endpoint(self.uniffiClonePointer(),$0
    )
})
}
    
open func deferredCredentialEndpoint() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_deferred_credential_endpoint(self.uniffiClonePointer(),$0
    )
})
}
    
open func issuer() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_issuer(self.uniffiClonePointer(),$0
    )
})
}
    
open func notificationEndpoint() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_notification_endpoint(self.uniffiClonePointer(),$0
    )
})
}
    
open func toJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_to_json(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeOid4vciMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Oid4vciMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vciMetadata {
        return Oid4vciMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Oid4vciMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vciMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Oid4vciMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOid4vciMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vciMetadata {
    return try FfiConverterTypeOid4vciMetadata.lift(pointer)
}

public func FfiConverterTypeOid4vciMetadata_lower(_ value: Oid4vciMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOid4vciMetadata.lower(value)
}




public protocol Oid4vciSessionProtocol : AnyObject {
    
}

open class Oid4vciSession:
    Oid4vciSessionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_oid4vcisession(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_oid4vcisession(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeOid4vciSession: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Oid4vciSession

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vciSession {
        return Oid4vciSession(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Oid4vciSession) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vciSession {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Oid4vciSession, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOid4vciSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vciSession {
    return try FfiConverterTypeOid4vciSession.lift(pointer)
}

public func FfiConverterTypeOid4vciSession_lower(_ value: Oid4vciSession) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOid4vciSession.lower(value)
}




/**
 * A credential that has been parsed as a known variant.
 */
public protocol ParsedCredentialProtocol : AnyObject {
    
    /**
     * Return the credential as a JsonVc if it is of that format.
     */
    func asJsonVc()  -> JsonVc?
    
    /**
     * Return the credential as a JwtVc if it is of that format.
     */
    func asJwtVc()  -> JwtVc?
    
    /**
     * Return the credential as an Mdoc if it is of that format.
     */
    func asMsoMdoc()  -> Mdoc?
    
    /**
     * Return the credential as an SD-JWT, if it is of that format.
     */
    func asSdJwt()  -> Vcdm2SdJwt?
    
    /**
     * Return the format of the credential.
     */
    func format()  -> CredentialFormat
    
    /**
     * Get the local ID for this credential.
     */
    func id()  -> Uuid
    
    /**
     * Convert a parsed credential into the generic form for storage.
     */
    func intoGenericForm() throws  -> Credential
    
    /**
     * Get the key alias for this credential.
     */
    func keyAlias()  -> KeyAlias?
    
    /**
     * Return the CredentialType from the parsed credential.
     */
    func type()  -> CredentialType
    
}

/**
 * A credential that has been parsed as a known variant.
 */
open class ParsedCredential:
    ParsedCredentialProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_parsedcredential(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_parsedcredential(pointer, $0) }
    }

    
public static func newFromJson(jsonString: String)throws  -> ParsedCredential {
    return try  FfiConverterTypeParsedCredential.lift(try rustCallWithError(FfiConverterTypeCredentialDecodingError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_from_json(
        FfiConverterString.lower(jsonString),$0
    )
})
}
    
    /**
     * Construct a new `jwt_vc_json` credential.
     */
public static func newJwtVcJson(jwtVc: JwtVc) -> ParsedCredential {
    return try!  FfiConverterTypeParsedCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_jwt_vc_json(
        FfiConverterTypeJwtVc.lower(jwtVc),$0
    )
})
}
    
    /**
     * Construct a new `jwt_vc_json-ld` credential.
     */
public static func newJwtVcJsonLd(jwtVc: JwtVc) -> ParsedCredential {
    return try!  FfiConverterTypeParsedCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_jwt_vc_json_ld(
        FfiConverterTypeJwtVc.lower(jwtVc),$0
    )
})
}
    
    /**
     * Construct a new `ldp_vc` credential.
     */
public static func newLdpVc(jsonVc: JsonVc) -> ParsedCredential {
    return try!  FfiConverterTypeParsedCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_ldp_vc(
        FfiConverterTypeJsonVc.lower(jsonVc),$0
    )
})
}
    
    /**
     * Construct a new `mso_mdoc` credential.
     */
public static func newMsoMdoc(mdoc: Mdoc) -> ParsedCredential {
    return try!  FfiConverterTypeParsedCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_mso_mdoc(
        FfiConverterTypeMdoc.lower(mdoc),$0
    )
})
}
    
    /**
     * Construct a new `sd_jwt_vc` credential.
     */
public static func newSdJwt(sdJwtVc: Vcdm2SdJwt) -> ParsedCredential {
    return try!  FfiConverterTypeParsedCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_sd_jwt(
        FfiConverterTypeVCDM2SdJwt.lower(sdJwtVc),$0
    )
})
}
    
    /**
     * Parse a credential from the generic form retrieved from storage.
     */
public static func parseFromCredential(credential: Credential)throws  -> ParsedCredential {
    return try  FfiConverterTypeParsedCredential.lift(try rustCallWithError(FfiConverterTypeCredentialDecodingError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_parse_from_credential(
        FfiConverterTypeCredential.lower(credential),$0
    )
})
}
    

    
    /**
     * Return the credential as a JsonVc if it is of that format.
     */
open func asJsonVc() -> JsonVc? {
    return try!  FfiConverterOptionTypeJsonVc.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_as_json_vc(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the credential as a JwtVc if it is of that format.
     */
open func asJwtVc() -> JwtVc? {
    return try!  FfiConverterOptionTypeJwtVc.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_as_jwt_vc(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the credential as an Mdoc if it is of that format.
     */
open func asMsoMdoc() -> Mdoc? {
    return try!  FfiConverterOptionTypeMdoc.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_as_mso_mdoc(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the credential as an SD-JWT, if it is of that format.
     */
open func asSdJwt() -> Vcdm2SdJwt? {
    return try!  FfiConverterOptionTypeVCDM2SdJwt.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_as_sd_jwt(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the format of the credential.
     */
open func format() -> CredentialFormat {
    return try!  FfiConverterTypeCredentialFormat.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_format(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the local ID for this credential.
     */
open func id() -> Uuid {
    return try!  FfiConverterTypeUuid.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Convert a parsed credential into the generic form for storage.
     */
open func intoGenericForm()throws  -> Credential {
    return try  FfiConverterTypeCredential.lift(try rustCallWithError(FfiConverterTypeCredentialEncodingError.lift) {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_into_generic_form(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the key alias for this credential.
     */
open func keyAlias() -> KeyAlias? {
    return try!  FfiConverterOptionTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the CredentialType from the parsed credential.
     */
open func type() -> CredentialType {
    return try!  FfiConverterTypeCredentialType.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_type(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeParsedCredential: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ParsedCredential

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ParsedCredential {
        return ParsedCredential(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ParsedCredential) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsedCredential {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ParsedCredential, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeParsedCredential_lift(_ pointer: UnsafeMutableRawPointer) throws -> ParsedCredential {
    return try FfiConverterTypeParsedCredential.lift(pointer)
}

public func FfiConverterTypeParsedCredential_lower(_ value: ParsedCredential) -> UnsafeMutableRawPointer {
    return FfiConverterTypeParsedCredential.lower(value)
}




public protocol PermissionRequestProtocol : AnyObject {
    
    /**
     * Construct a new permission response for the given credential.
     */
    func createPermissionResponse(selectedCredentials: [ParsedCredential]) async throws  -> PermissionResponse
    
    /**
     * Return the filtered list of credentials that matched
     * the presentation definition.
     */
    func credentials()  -> [ParsedCredential]
    
    /**
     * Return the purpose of the presentation request.
     */
    func purpose()  -> String?
    
    /**
     * Return the requested fields for a given credential.
     *
     * NOTE: This will return only the requested fields for a given credential.
     */
    func requestedFields(credential: ParsedCredential)  -> [RequestedField]
    
}

open class PermissionRequest:
    PermissionRequestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_permissionrequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_permissionrequest(pointer, $0) }
    }

    

    
    /**
     * Construct a new permission response for the given credential.
     */
open func createPermissionResponse(selectedCredentials: [ParsedCredential])async throws  -> PermissionResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_permissionrequest_create_permission_response(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeParsedCredential.lower(selectedCredentials)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypePermissionResponse.lift,
            errorHandler: FfiConverterTypeOID4VPError.lift
        )
}
    
    /**
     * Return the filtered list of credentials that matched
     * the presentation definition.
     */
open func credentials() -> [ParsedCredential] {
    return try!  FfiConverterSequenceTypeParsedCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_permissionrequest_credentials(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the purpose of the presentation request.
     */
open func purpose() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_permissionrequest_purpose(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the requested fields for a given credential.
     *
     * NOTE: This will return only the requested fields for a given credential.
     */
open func requestedFields(credential: ParsedCredential) -> [RequestedField] {
    return try!  FfiConverterSequenceTypeRequestedField.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_permissionrequest_requested_fields(self.uniffiClonePointer(),
        FfiConverterTypeParsedCredential.lower(credential),$0
    )
})
}
    

}

public struct FfiConverterTypePermissionRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PermissionRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PermissionRequest {
        return PermissionRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PermissionRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PermissionRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PermissionRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypePermissionRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> PermissionRequest {
    return try FfiConverterTypePermissionRequest.lift(pointer)
}

public func FfiConverterTypePermissionRequest_lower(_ value: PermissionRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypePermissionRequest.lower(value)
}




/**
 * This struct is used to represent the response to a permission request.
 *
 * Use the [PermissionResponse::new] method to create a new instance of the PermissionResponse.
 *
 * The Requested Fields are created by calling the [PermissionRequest::requested_fields] method, and then
 * explicitly setting the permission to true or false, based on the holder's decision.
 */
public protocol PermissionResponseProtocol : AnyObject {
    
    /**
     * Return the selected credentials for the permission response.
     */
    func selectedCredentials()  -> [ParsedCredential]
    
}

/**
 * This struct is used to represent the response to a permission request.
 *
 * Use the [PermissionResponse::new] method to create a new instance of the PermissionResponse.
 *
 * The Requested Fields are created by calling the [PermissionRequest::requested_fields] method, and then
 * explicitly setting the permission to true or false, based on the holder's decision.
 */
open class PermissionResponse:
    PermissionResponseProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_permissionresponse(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_permissionresponse(pointer, $0) }
    }

    

    
    /**
     * Return the selected credentials for the permission response.
     */
open func selectedCredentials() -> [ParsedCredential] {
    return try!  FfiConverterSequenceTypeParsedCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_permissionresponse_selected_credentials(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypePermissionResponse: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PermissionResponse

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PermissionResponse {
        return PermissionResponse(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PermissionResponse) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PermissionResponse {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PermissionResponse, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypePermissionResponse_lift(_ pointer: UnsafeMutableRawPointer) throws -> PermissionResponse {
    return try FfiConverterTypePermissionResponse.lift(pointer)
}

public func FfiConverterTypePermissionResponse_lower(_ value: PermissionResponse) -> UnsafeMutableRawPointer {
    return FfiConverterTypePermissionResponse.lower(value)
}




public protocol RequestedFieldProtocol : AnyObject {
    
    /**
     * Return the field name
     */
    func name()  -> String?
    
    /**
     * Return the purpose of the requested field.
     */
    func purpose()  -> String?
    
    /**
     * Return the stringified JSON raw fields.
     */
    func rawFields()  -> [String]
    
    /**
     * Return the field required status
     */
    func required()  -> Bool
    
    /**
     * Return the field retained status
     */
    func retained()  -> Bool
    
}

open class RequestedField:
    RequestedFieldProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_requestedfield(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_requestedfield(pointer, $0) }
    }

    

    
    /**
     * Return the field name
     */
open func name() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_name(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the purpose of the requested field.
     */
open func purpose() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_purpose(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the stringified JSON raw fields.
     */
open func rawFields() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_raw_fields(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the field required status
     */
open func required() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_required(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the field retained status
     */
open func retained() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_retained(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeRequestedField: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RequestedField

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RequestedField {
        return RequestedField(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RequestedField) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedField {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RequestedField, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRequestedField_lift(_ pointer: UnsafeMutableRawPointer) throws -> RequestedField {
    return try FfiConverterTypeRequestedField.lift(pointer)
}

public func FfiConverterTypeRequestedField_lower(_ value: RequestedField) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRequestedField.lower(value)
}




/**
 * Status provides a value and purpose for a status,
 *
 * The value is the raw value of the status at the entry list index,
 * and the purpose is the purpose of the credential, which is used
 * to interpret the value.
 */
public protocol StatusProtocol : AnyObject {
    
    /**
     * Return whether the credential status has a message.
     */
    func isMessage()  -> Bool
    
    /**
     * Return whether the credential status is revoked.
     */
    func isRevoked()  -> Bool
    
    /**
     * Return whether the credential status is suspended.
     */
    func isSuspended()  -> Bool
    
    /**
     * Return the message of the credential status.
     */
    func messages()  -> [StatusMessage]
    
    /**
     * Return the purpose of the status.
     */
    func purpose()  -> StatusPurpose
    
}

/**
 * Status provides a value and purpose for a status,
 *
 * The value is the raw value of the status at the entry list index,
 * and the purpose is the purpose of the credential, which is used
 * to interpret the value.
 */
open class Status:
    StatusProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_status(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_status(pointer, $0) }
    }

    

    
    /**
     * Return whether the credential status has a message.
     */
open func isMessage() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status_is_message(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return whether the credential status is revoked.
     */
open func isRevoked() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status_is_revoked(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return whether the credential status is suspended.
     */
open func isSuspended() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status_is_suspended(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the message of the credential status.
     */
open func messages() -> [StatusMessage] {
    return try!  FfiConverterSequenceTypeStatusMessage.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status_messages(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the purpose of the status.
     */
open func purpose() -> StatusPurpose {
    return try!  FfiConverterTypeStatusPurpose.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status_purpose(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeStatus: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Status

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Status {
        return Status(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Status) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Status {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Status, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeStatus_lift(_ pointer: UnsafeMutableRawPointer) throws -> Status {
    return try FfiConverterTypeStatus.lift(pointer)
}

public func FfiConverterTypeStatus_lower(_ value: Status) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStatus.lower(value)
}




/**
 * Interface: StorageManagerInterface
 *
 * The StorageManagerInterface provides access to functions defined in Kotlin and Swift for
 * managing persistent storage on the device.
 *
 * When dealing with UniFFI exported functions and objects, this will need to be Boxed as:
 * Box<dyn StorageManagerInterface>
 *
 * We use the older callback_interface to keep the required version level of our Android API
 * low.
 */
public protocol StorageManagerInterface : AnyObject {
    
    /**
     * Function: add
     *
     * Adds a key-value pair to storage.  Should the key already exist, the value will be
     * replaced
     *
     * Arguments:
     * key - The key to add
     * value - The value to add under the key.
     */
    func add(key: Key, value: Value) throws 
    
    /**
     * Function: get
     *
     * Callback function pointer to native (kotlin/swift) code for
     * getting a key.
     */
    func get(key: Key) throws  -> Value?
    
    /**
     * Function: list
     *
     * Callback function pointer for listing available keys.
     */
    func list() throws  -> [Key]
    
    /**
     * Function: remove
     *
     * Callback function pointer to native (kotlin/swift) code for
     * removing a key.  This referenced function MUST be idempotent.  In
     * particular, it must treat removing a non-existent key as a normal and
     * expected circumstance, simply returning () and not an error.
     */
    func remove(key: Key) throws 
    
}

/**
 * Interface: StorageManagerInterface
 *
 * The StorageManagerInterface provides access to functions defined in Kotlin and Swift for
 * managing persistent storage on the device.
 *
 * When dealing with UniFFI exported functions and objects, this will need to be Boxed as:
 * Box<dyn StorageManagerInterface>
 *
 * We use the older callback_interface to keep the required version level of our Android API
 * low.
 */
open class StorageManagerInterfaceImpl:
    StorageManagerInterface {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_storagemanagerinterface(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_storagemanagerinterface(pointer, $0) }
    }

    

    
    /**
     * Function: add
     *
     * Adds a key-value pair to storage.  Should the key already exist, the value will be
     * replaced
     *
     * Arguments:
     * key - The key to add
     * value - The value to add under the key.
     */
open func add(key: Key, value: Value)throws  {try rustCallWithError(FfiConverterTypeStorageManagerError.lift) {
    uniffi_mobile_sdk_rs_fn_method_storagemanagerinterface_add(self.uniffiClonePointer(),
        FfiConverterTypeKey.lower(key),
        FfiConverterTypeValue.lower(value),$0
    )
}
}
    
    /**
     * Function: get
     *
     * Callback function pointer to native (kotlin/swift) code for
     * getting a key.
     */
open func get(key: Key)throws  -> Value? {
    return try  FfiConverterOptionTypeValue.lift(try rustCallWithError(FfiConverterTypeStorageManagerError.lift) {
    uniffi_mobile_sdk_rs_fn_method_storagemanagerinterface_get(self.uniffiClonePointer(),
        FfiConverterTypeKey.lower(key),$0
    )
})
}
    
    /**
     * Function: list
     *
     * Callback function pointer for listing available keys.
     */
open func list()throws  -> [Key] {
    return try  FfiConverterSequenceTypeKey.lift(try rustCallWithError(FfiConverterTypeStorageManagerError.lift) {
    uniffi_mobile_sdk_rs_fn_method_storagemanagerinterface_list(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Function: remove
     *
     * Callback function pointer to native (kotlin/swift) code for
     * removing a key.  This referenced function MUST be idempotent.  In
     * particular, it must treat removing a non-existent key as a normal and
     * expected circumstance, simply returning () and not an error.
     */
open func remove(key: Key)throws  {try rustCallWithError(FfiConverterTypeStorageManagerError.lift) {
    uniffi_mobile_sdk_rs_fn_method_storagemanagerinterface_remove(self.uniffiClonePointer(),
        FfiConverterTypeKey.lower(key),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceStorageManagerInterface {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceStorageManagerInterface = UniffiVTableCallbackInterfaceStorageManagerInterface(
        add: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            value: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorageManagerInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.add(
                     key: try FfiConverterTypeKey.lift(key),
                     value: try FfiConverterTypeValue.lift(value)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeStorageManagerError.lower
            )
        },
        get: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Value? in
                guard let uniffiObj = try? FfiConverterTypeStorageManagerInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.get(
                     key: try FfiConverterTypeKey.lift(key)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeValue.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeStorageManagerError.lower
            )
        },
        list: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> [Key] in
                guard let uniffiObj = try? FfiConverterTypeStorageManagerInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.list(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterSequenceTypeKey.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeStorageManagerError.lower
            )
        },
        remove: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorageManagerInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.remove(
                     key: try FfiConverterTypeKey.lift(key)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeStorageManagerError.lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeStorageManagerInterface.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface StorageManagerInterface: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitStorageManagerInterface() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_storagemanagerinterface(&UniffiCallbackInterfaceStorageManagerInterface.vtable)
}

public struct FfiConverterTypeStorageManagerInterface: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<StorageManagerInterface>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = StorageManagerInterface

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> StorageManagerInterface {
        return StorageManagerInterfaceImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: StorageManagerInterface) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageManagerInterface {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: StorageManagerInterface, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeStorageManagerInterface_lift(_ pointer: UnsafeMutableRawPointer) throws -> StorageManagerInterface {
    return try FfiConverterTypeStorageManagerInterface.lift(pointer)
}

public func FfiConverterTypeStorageManagerInterface_lower(_ value: StorageManagerInterface) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStorageManagerInterface.lower(value)
}




public protocol SyncHttpClient : AnyObject {
    
    func httpClient(request: HttpRequest) throws  -> HttpResponse
    
}

open class SyncHttpClientImpl:
    SyncHttpClient {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_synchttpclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_synchttpclient(pointer, $0) }
    }

    

    
open func httpClient(request: HttpRequest)throws  -> HttpResponse {
    return try  FfiConverterTypeHttpResponse.lift(try rustCallWithError(FfiConverterTypeHttpClientError.lift) {
    uniffi_mobile_sdk_rs_fn_method_synchttpclient_http_client(self.uniffiClonePointer(),
        FfiConverterTypeHttpRequest.lower(request),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSyncHttpClient {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSyncHttpClient = UniffiVTableCallbackInterfaceSyncHttpClient(
        httpClient: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> HttpResponse in
                guard let uniffiObj = try? FfiConverterTypeSyncHttpClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.httpClient(
                     request: try FfiConverterTypeHttpRequest.lift(request)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeHttpResponse.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeHttpClientError.lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeSyncHttpClient.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SyncHttpClient: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSyncHttpClient() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_synchttpclient(&UniffiCallbackInterfaceSyncHttpClient.vtable)
}

public struct FfiConverterTypeSyncHttpClient: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<SyncHttpClient>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncHttpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncHttpClient {
        return SyncHttpClientImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncHttpClient) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncHttpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncHttpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSyncHttpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncHttpClient {
    return try FfiConverterTypeSyncHttpClient.lift(pointer)
}

public func FfiConverterTypeSyncHttpClient_lower(_ value: SyncHttpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncHttpClient.lower(value)
}




public protocol TokenResponseProtocol : AnyObject {
    
}

open class TokenResponse:
    TokenResponseProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_tokenresponse(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_tokenresponse(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeTokenResponse: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TokenResponse

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TokenResponse {
        return TokenResponse(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TokenResponse) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenResponse {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TokenResponse, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTokenResponse_lift(_ pointer: UnsafeMutableRawPointer) throws -> TokenResponse {
    return try FfiConverterTypeTokenResponse.lift(pointer)
}

public func FfiConverterTypeTokenResponse_lower(_ value: TokenResponse) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTokenResponse.lower(value)
}




public protocol Vcdm2SdJwtProtocol : AnyObject {
    
    /**
     * Return the ID for the SdJwt instance.
     */
    func id()  -> Uuid
    
    /**
     * Return the key alias for the credential
     */
    func keyAlias()  -> KeyAlias?
    
    /**
     * Return the revealed claims as a UTF-8 encoded JSON string.
     */
    func revealedClaimsAsJsonString() throws  -> String
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
    func type()  -> CredentialType
    
}

open class Vcdm2SdJwt:
    Vcdm2SdJwtProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_vcdm2sdjwt(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_vcdm2sdjwt(pointer, $0) }
    }

    
    /**
     * Create a new SdJwt instance from a compact SD-JWS string.
     */
public static func newFromCompactSdJwt(input: String)throws  -> Vcdm2SdJwt {
    return try  FfiConverterTypeVCDM2SdJwt.lift(try rustCallWithError(FfiConverterTypeSdJwtError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_vcdm2sdjwt_new_from_compact_sd_jwt(
        FfiConverterString.lower(input),$0
    )
})
}
    
    /**
     * Create a new SdJwt instance from a compact SD-JWS string with a provided key alias.
     */
public static func newFromCompactSdJwtWithKey(input: String, keyAlias: KeyAlias)throws  -> Vcdm2SdJwt {
    return try  FfiConverterTypeVCDM2SdJwt.lift(try rustCallWithError(FfiConverterTypeSdJwtError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_vcdm2sdjwt_new_from_compact_sd_jwt_with_key(
        FfiConverterString.lower(input),
        FfiConverterTypeKeyAlias.lower(keyAlias),$0
    )
})
}
    

    
    /**
     * Return the ID for the SdJwt instance.
     */
open func id() -> Uuid {
    return try!  FfiConverterTypeUuid.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_vcdm2sdjwt_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the key alias for the credential
     */
open func keyAlias() -> KeyAlias? {
    return try!  FfiConverterOptionTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_vcdm2sdjwt_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the revealed claims as a UTF-8 encoded JSON string.
     */
open func revealedClaimsAsJsonString()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeSdJwtError.lift) {
    uniffi_mobile_sdk_rs_fn_method_vcdm2sdjwt_revealed_claims_as_json_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
open func type() -> CredentialType {
    return try!  FfiConverterTypeCredentialType.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_vcdm2sdjwt_type(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeVCDM2SdJwt: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Vcdm2SdJwt

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Vcdm2SdJwt {
        return Vcdm2SdJwt(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Vcdm2SdJwt) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Vcdm2SdJwt {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Vcdm2SdJwt, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeVCDM2SdJwt_lift(_ pointer: UnsafeMutableRawPointer) throws -> Vcdm2SdJwt {
    return try FfiConverterTypeVCDM2SdJwt.lift(pointer)
}

public func FfiConverterTypeVCDM2SdJwt_lower(_ value: Vcdm2SdJwt) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVCDM2SdJwt.lower(value)
}




/**
 * Verifiable Digital Credential Collection
 *
 * This is the main interface to credentials.
 */
public protocol VdcCollectionProtocol : AnyObject {
    
    /**
     * Add a credential to the set.
     */
    func add(credential: Credential) throws 
    
    /**
     * Get a list of all the credentials.
     */
    func allEntries() throws  -> [Uuid]
    
    /**
     * Get a list of all the credentials that match a specified type.
     */
    func allEntriesByType(ctype: CredentialType) throws  -> [Uuid]
    
    /**
     * Remove a credential from the store.
     */
    func delete(id: Uuid) throws 
    
    /**
     * Dump the contents of the credential set to the logger.
     */
    func dump() 
    
    /**
     * Get a credential from the store.
     */
    func get(id: Uuid) throws  -> Credential?
    
}

/**
 * Verifiable Digital Credential Collection
 *
 * This is the main interface to credentials.
 */
open class VdcCollection:
    VdcCollectionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_vdccollection(self.pointer, $0) }
    }
    /**
     * Create a new credential set.
     */
public convenience init(engine: StorageManagerInterface) {
    let pointer =
        try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_vdccollection_new(
        FfiConverterTypeStorageManagerInterface.lower(engine),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_vdccollection(pointer, $0) }
    }

    

    
    /**
     * Add a credential to the set.
     */
open func add(credential: Credential)throws  {try rustCallWithError(FfiConverterTypeVdcCollectionError.lift) {
    uniffi_mobile_sdk_rs_fn_method_vdccollection_add(self.uniffiClonePointer(),
        FfiConverterTypeCredential.lower(credential),$0
    )
}
}
    
    /**
     * Get a list of all the credentials.
     */
open func allEntries()throws  -> [Uuid] {
    return try  FfiConverterSequenceTypeUuid.lift(try rustCallWithError(FfiConverterTypeVdcCollectionError.lift) {
    uniffi_mobile_sdk_rs_fn_method_vdccollection_all_entries(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get a list of all the credentials that match a specified type.
     */
open func allEntriesByType(ctype: CredentialType)throws  -> [Uuid] {
    return try  FfiConverterSequenceTypeUuid.lift(try rustCallWithError(FfiConverterTypeVdcCollectionError.lift) {
    uniffi_mobile_sdk_rs_fn_method_vdccollection_all_entries_by_type(self.uniffiClonePointer(),
        FfiConverterTypeCredentialType.lower(ctype),$0
    )
})
}
    
    /**
     * Remove a credential from the store.
     */
open func delete(id: Uuid)throws  {try rustCallWithError(FfiConverterTypeVdcCollectionError.lift) {
    uniffi_mobile_sdk_rs_fn_method_vdccollection_delete(self.uniffiClonePointer(),
        FfiConverterTypeUuid.lower(id),$0
    )
}
}
    
    /**
     * Dump the contents of the credential set to the logger.
     */
open func dump() {try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_vdccollection_dump(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Get a credential from the store.
     */
open func get(id: Uuid)throws  -> Credential? {
    return try  FfiConverterOptionTypeCredential.lift(try rustCallWithError(FfiConverterTypeVdcCollectionError.lift) {
    uniffi_mobile_sdk_rs_fn_method_vdccollection_get(self.uniffiClonePointer(),
        FfiConverterTypeUuid.lower(id),$0
    )
})
}
    

}

public struct FfiConverterTypeVdcCollection: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = VdcCollection

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> VdcCollection {
        return VdcCollection(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: VdcCollection) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VdcCollection {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: VdcCollection, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeVdcCollection_lift(_ pointer: UnsafeMutableRawPointer) throws -> VdcCollection {
    return try FfiConverterTypeVdcCollection.lift(pointer)
}

public func FfiConverterTypeVdcCollection_lower(_ value: VdcCollection) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVdcCollection.lower(value)
}


/**
 * An unparsed credential, retrieved from storage.
 */
public struct Credential {
    /**
     * The local ID of this credential.
     */
    public var id: Uuid
    /**
     * The format of this credential.
     */
    public var format: CredentialFormat
    /**
     * The type of this credential.
     */
    public var type: CredentialType
    /**
     * The raw payload of this credential. The encoding depends on the format.
     */
    public var payload: Data
    /**
     * The alias of the key that is authorized to present this credential.
     */
    public var keyAlias: KeyAlias?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The local ID of this credential.
         */id: Uuid, 
        /**
         * The format of this credential.
         */format: CredentialFormat, 
        /**
         * The type of this credential.
         */type: CredentialType, 
        /**
         * The raw payload of this credential. The encoding depends on the format.
         */payload: Data, 
        /**
         * The alias of the key that is authorized to present this credential.
         */keyAlias: KeyAlias?) {
        self.id = id
        self.format = format
        self.type = type
        self.payload = payload
        self.keyAlias = keyAlias
    }
}



extension Credential: Equatable, Hashable {
    public static func ==(lhs: Credential, rhs: Credential) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.format != rhs.format {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.payload != rhs.payload {
            return false
        }
        if lhs.keyAlias != rhs.keyAlias {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(format)
        hasher.combine(type)
        hasher.combine(payload)
        hasher.combine(keyAlias)
    }
}


public struct FfiConverterTypeCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Credential {
        return
            try Credential(
                id: FfiConverterTypeUuid.read(from: &buf), 
                format: FfiConverterTypeCredentialFormat.read(from: &buf), 
                type: FfiConverterTypeCredentialType.read(from: &buf), 
                payload: FfiConverterData.read(from: &buf), 
                keyAlias: FfiConverterOptionTypeKeyAlias.read(from: &buf)
        )
    }

    public static func write(_ value: Credential, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeCredentialFormat.write(value.format, into: &buf)
        FfiConverterTypeCredentialType.write(value.type, into: &buf)
        FfiConverterData.write(value.payload, into: &buf)
        FfiConverterOptionTypeKeyAlias.write(value.keyAlias, into: &buf)
    }
}


public func FfiConverterTypeCredential_lift(_ buf: RustBuffer) throws -> Credential {
    return try FfiConverterTypeCredential.lift(buf)
}

public func FfiConverterTypeCredential_lower(_ value: Credential) -> RustBuffer {
    return FfiConverterTypeCredential.lower(value)
}


/**
 * Information about the verified credential.
 */
public struct CredentialInfo {
    /**
     * The credential title that should be displayed on the success screen.
     */
    public var title: String
    /**
     * The image that should be displayed on the success screen.
     */
    public var image: Data
    /**
     * The claims decoded from the credential.
     */
    public var claims: [String: ClaimValue]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The credential title that should be displayed on the success screen.
         */title: String, 
        /**
         * The image that should be displayed on the success screen.
         */image: Data, 
        /**
         * The claims decoded from the credential.
         */claims: [String: ClaimValue]) {
        self.title = title
        self.image = image
        self.claims = claims
    }
}



extension CredentialInfo: Equatable, Hashable {
    public static func ==(lhs: CredentialInfo, rhs: CredentialInfo) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.image != rhs.image {
            return false
        }
        if lhs.claims != rhs.claims {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(image)
        hasher.combine(claims)
    }
}


public struct FfiConverterTypeCredentialInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialInfo {
        return
            try CredentialInfo(
                title: FfiConverterString.read(from: &buf), 
                image: FfiConverterData.read(from: &buf), 
                claims: FfiConverterDictionaryStringTypeClaimValue.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterData.write(value.image, into: &buf)
        FfiConverterDictionaryStringTypeClaimValue.write(value.claims, into: &buf)
    }
}


public func FfiConverterTypeCredentialInfo_lift(_ buf: RustBuffer) throws -> CredentialInfo {
    return try FfiConverterTypeCredentialInfo.lift(buf)
}

public func FfiConverterTypeCredentialInfo_lower(_ value: CredentialInfo) -> RustBuffer {
    return FfiConverterTypeCredentialInfo.lower(value)
}


public struct CredentialResponse {
    public var format: CredentialFormat
    public var payload: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(format: CredentialFormat, payload: Data) {
        self.format = format
        self.payload = payload
    }
}



extension CredentialResponse: Equatable, Hashable {
    public static func ==(lhs: CredentialResponse, rhs: CredentialResponse) -> Bool {
        if lhs.format != rhs.format {
            return false
        }
        if lhs.payload != rhs.payload {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(format)
        hasher.combine(payload)
    }
}


public struct FfiConverterTypeCredentialResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialResponse {
        return
            try CredentialResponse(
                format: FfiConverterTypeCredentialFormat.read(from: &buf), 
                payload: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialResponse, into buf: inout [UInt8]) {
        FfiConverterTypeCredentialFormat.write(value.format, into: &buf)
        FfiConverterData.write(value.payload, into: &buf)
    }
}


public func FfiConverterTypeCredentialResponse_lift(_ buf: RustBuffer) throws -> CredentialResponse {
    return try FfiConverterTypeCredentialResponse.lift(buf)
}

public func FfiConverterTypeCredentialResponse_lower(_ value: CredentialResponse) -> RustBuffer {
    return FfiConverterTypeCredentialResponse.lower(value)
}


public struct DelegateInitializationResponse {
    /**
     * This is the authorization request URL to be presented in
     * a QR code to the holder.
     */
    public var authQuery: String
    /**
     * This is the status URL to check the presentation status
     * from the delegated verifier.
     */
    public var uri: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * This is the authorization request URL to be presented in
         * a QR code to the holder.
         */authQuery: String, 
        /**
         * This is the status URL to check the presentation status
         * from the delegated verifier.
         */uri: String) {
        self.authQuery = authQuery
        self.uri = uri
    }
}



extension DelegateInitializationResponse: Equatable, Hashable {
    public static func ==(lhs: DelegateInitializationResponse, rhs: DelegateInitializationResponse) -> Bool {
        if lhs.authQuery != rhs.authQuery {
            return false
        }
        if lhs.uri != rhs.uri {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(authQuery)
        hasher.combine(uri)
    }
}


public struct FfiConverterTypeDelegateInitializationResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DelegateInitializationResponse {
        return
            try DelegateInitializationResponse(
                authQuery: FfiConverterString.read(from: &buf), 
                uri: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DelegateInitializationResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.authQuery, into: &buf)
        FfiConverterString.write(value.uri, into: &buf)
    }
}


public func FfiConverterTypeDelegateInitializationResponse_lift(_ buf: RustBuffer) throws -> DelegateInitializationResponse {
    return try FfiConverterTypeDelegateInitializationResponse.lift(buf)
}

public func FfiConverterTypeDelegateInitializationResponse_lower(_ value: DelegateInitializationResponse) -> RustBuffer {
    return FfiConverterTypeDelegateInitializationResponse.lower(value)
}


public struct DelegatedVerifierOid4vpResponse {
    /**
     * Presented SD-JWT.
     */
    public var vpToken: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Presented SD-JWT.
         */vpToken: String) {
        self.vpToken = vpToken
    }
}



extension DelegatedVerifierOid4vpResponse: Equatable, Hashable {
    public static func ==(lhs: DelegatedVerifierOid4vpResponse, rhs: DelegatedVerifierOid4vpResponse) -> Bool {
        if lhs.vpToken != rhs.vpToken {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(vpToken)
    }
}


public struct FfiConverterTypeDelegatedVerifierOid4vpResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DelegatedVerifierOid4vpResponse {
        return
            try DelegatedVerifierOid4vpResponse(
                vpToken: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DelegatedVerifierOid4vpResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.vpToken, into: &buf)
    }
}


public func FfiConverterTypeDelegatedVerifierOid4vpResponse_lift(_ buf: RustBuffer) throws -> DelegatedVerifierOid4vpResponse {
    return try FfiConverterTypeDelegatedVerifierOid4vpResponse.lift(buf)
}

public func FfiConverterTypeDelegatedVerifierOid4vpResponse_lower(_ value: DelegatedVerifierOid4vpResponse) -> RustBuffer {
    return FfiConverterTypeDelegatedVerifierOid4vpResponse.lower(value)
}


public struct DelegatedVerifierStatusResponse {
    /**
     * The status of the verification request.
     */
    public var status: DelegatedVerifierStatus
    /**
     * OID4VP presentation
     */
    public var oid4vp: DelegatedVerifierOid4vpResponse?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The status of the verification request.
         */status: DelegatedVerifierStatus, 
        /**
         * OID4VP presentation
         */oid4vp: DelegatedVerifierOid4vpResponse?) {
        self.status = status
        self.oid4vp = oid4vp
    }
}



extension DelegatedVerifierStatusResponse: Equatable, Hashable {
    public static func ==(lhs: DelegatedVerifierStatusResponse, rhs: DelegatedVerifierStatusResponse) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.oid4vp != rhs.oid4vp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(oid4vp)
    }
}


public struct FfiConverterTypeDelegatedVerifierStatusResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DelegatedVerifierStatusResponse {
        return
            try DelegatedVerifierStatusResponse(
                status: FfiConverterTypeDelegatedVerifierStatus.read(from: &buf), 
                oid4vp: FfiConverterOptionTypeDelegatedVerifierOid4vpResponse.read(from: &buf)
        )
    }

    public static func write(_ value: DelegatedVerifierStatusResponse, into buf: inout [UInt8]) {
        FfiConverterTypeDelegatedVerifierStatus.write(value.status, into: &buf)
        FfiConverterOptionTypeDelegatedVerifierOid4vpResponse.write(value.oid4vp, into: &buf)
    }
}


public func FfiConverterTypeDelegatedVerifierStatusResponse_lift(_ buf: RustBuffer) throws -> DelegatedVerifierStatusResponse {
    return try FfiConverterTypeDelegatedVerifierStatusResponse.lift(buf)
}

public func FfiConverterTypeDelegatedVerifierStatusResponse_lower(_ value: DelegatedVerifierStatusResponse) -> RustBuffer {
    return FfiConverterTypeDelegatedVerifierStatusResponse.lower(value)
}


/**
 * Simple representation of an mdoc data element.
 */
public struct Element {
    /**
     * Name of the data element.
     */
    public var identifier: String
    /**
     * JSON representation of the data element, missing if the value cannot be represented as JSON.
     */
    public var value: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Name of the data element.
         */identifier: String, 
        /**
         * JSON representation of the data element, missing if the value cannot be represented as JSON.
         */value: String?) {
        self.identifier = identifier
        self.value = value
    }
}



extension Element: Equatable, Hashable {
    public static func ==(lhs: Element, rhs: Element) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(value)
    }
}


public struct FfiConverterTypeElement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Element {
        return
            try Element(
                identifier: FfiConverterString.read(from: &buf), 
                value: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Element, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterOptionString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeElement_lift(_ buf: RustBuffer) throws -> Element {
    return try FfiConverterTypeElement.lift(buf)
}

public func FfiConverterTypeElement_lower(_ value: Element) -> RustBuffer {
    return FfiConverterTypeElement.lower(value)
}


/**
 * A verification failure with a code and reason.
 */
public struct Failure {
    public var code: UInt64
    public var reason: String
    public var details: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(code: UInt64, reason: String, details: String) {
        self.code = code
        self.reason = reason
        self.details = details
    }
}



extension Failure: Equatable, Hashable {
    public static func ==(lhs: Failure, rhs: Failure) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(reason)
        hasher.combine(details)
    }
}


public struct FfiConverterTypeFailure: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Failure {
        return
            try Failure(
                code: FfiConverterUInt64.read(from: &buf), 
                reason: FfiConverterString.read(from: &buf), 
                details: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Failure, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.code, into: &buf)
        FfiConverterString.write(value.reason, into: &buf)
        FfiConverterString.write(value.details, into: &buf)
    }
}


public func FfiConverterTypeFailure_lift(_ buf: RustBuffer) throws -> Failure {
    return try FfiConverterTypeFailure.lift(buf)
}

public func FfiConverterTypeFailure_lower(_ value: Failure) -> RustBuffer {
    return FfiConverterTypeFailure.lower(value)
}


/**
 * Plain Rust object representation of an HttpRequest that can be exported
 * through `uniffi` and is used in `WithForeign` trait definitions for HTTP
 * clients.
 */
public struct HttpRequest {
    public var url: String
    public var method: String
    public var headers: [String: String]
    public var body: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, method: String, headers: [String: String], body: Data) {
        self.url = url
        self.method = method
        self.headers = headers
        self.body = body
    }
}



extension HttpRequest: Equatable, Hashable {
    public static func ==(lhs: HttpRequest, rhs: HttpRequest) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(method)
        hasher.combine(headers)
        hasher.combine(body)
    }
}


public struct FfiConverterTypeHttpRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpRequest {
        return
            try HttpRequest(
                url: FfiConverterString.read(from: &buf), 
                method: FfiConverterString.read(from: &buf), 
                headers: FfiConverterDictionaryStringString.read(from: &buf), 
                body: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: HttpRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.method, into: &buf)
        FfiConverterDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterData.write(value.body, into: &buf)
    }
}


public func FfiConverterTypeHttpRequest_lift(_ buf: RustBuffer) throws -> HttpRequest {
    return try FfiConverterTypeHttpRequest.lift(buf)
}

public func FfiConverterTypeHttpRequest_lower(_ value: HttpRequest) -> RustBuffer {
    return FfiConverterTypeHttpRequest.lower(value)
}


/**
 * Plain Rust object representation of an HttpResponse that can be exported
 * through `uniffi` and is used in `WithForeign` trait definitions for HTTP
 * clients.
 */
public struct HttpResponse {
    public var statusCode: UInt16
    public var headers: [String: String]
    public var body: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(statusCode: UInt16, headers: [String: String], body: Data) {
        self.statusCode = statusCode
        self.headers = headers
        self.body = body
    }
}



extension HttpResponse: Equatable, Hashable {
    public static func ==(lhs: HttpResponse, rhs: HttpResponse) -> Bool {
        if lhs.statusCode != rhs.statusCode {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(statusCode)
        hasher.combine(headers)
        hasher.combine(body)
    }
}


public struct FfiConverterTypeHttpResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpResponse {
        return
            try HttpResponse(
                statusCode: FfiConverterUInt16.read(from: &buf), 
                headers: FfiConverterDictionaryStringString.read(from: &buf), 
                body: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: HttpResponse, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.statusCode, into: &buf)
        FfiConverterDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterData.write(value.body, into: &buf)
    }
}


public func FfiConverterTypeHttpResponse_lift(_ buf: RustBuffer) throws -> HttpResponse {
    return try FfiConverterTypeHttpResponse.lift(buf)
}

public func FfiConverterTypeHttpResponse_lower(_ value: HttpResponse) -> RustBuffer {
    return FfiConverterTypeHttpResponse.lower(value)
}


public struct ItemsRequest {
    public var docType: String
    public var namespaces: [String: [String: Bool]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(docType: String, namespaces: [String: [String: Bool]]) {
        self.docType = docType
        self.namespaces = namespaces
    }
}



extension ItemsRequest: Equatable, Hashable {
    public static func ==(lhs: ItemsRequest, rhs: ItemsRequest) -> Bool {
        if lhs.docType != rhs.docType {
            return false
        }
        if lhs.namespaces != rhs.namespaces {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(docType)
        hasher.combine(namespaces)
    }
}


public struct FfiConverterTypeItemsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ItemsRequest {
        return
            try ItemsRequest(
                docType: FfiConverterString.read(from: &buf), 
                namespaces: FfiConverterDictionaryStringDictionaryStringBool.read(from: &buf)
        )
    }

    public static func write(_ value: ItemsRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.docType, into: &buf)
        FfiConverterDictionaryStringDictionaryStringBool.write(value.namespaces, into: &buf)
    }
}


public func FfiConverterTypeItemsRequest_lift(_ buf: RustBuffer) throws -> ItemsRequest {
    return try FfiConverterTypeItemsRequest.lift(buf)
}

public func FfiConverterTypeItemsRequest_lower(_ value: ItemsRequest) -> RustBuffer {
    return FfiConverterTypeItemsRequest.lower(value)
}


public struct MdlReaderResponseData {
    public var state: MdlSessionManager
    /**
     * Contains the namespaces for the mDL directly, without top-level doc types
     */
    public var verifiedResponse: [String: [String: MDocItem]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: MdlSessionManager, 
        /**
         * Contains the namespaces for the mDL directly, without top-level doc types
         */verifiedResponse: [String: [String: MDocItem]]) {
        self.state = state
        self.verifiedResponse = verifiedResponse
    }
}



public struct FfiConverterTypeMDLReaderResponseData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderResponseData {
        return
            try MdlReaderResponseData(
                state: FfiConverterTypeMDLSessionManager.read(from: &buf), 
                verifiedResponse: FfiConverterDictionaryStringDictionaryStringTypeMDocItem.read(from: &buf)
        )
    }

    public static func write(_ value: MdlReaderResponseData, into buf: inout [UInt8]) {
        FfiConverterTypeMDLSessionManager.write(value.state, into: &buf)
        FfiConverterDictionaryStringDictionaryStringTypeMDocItem.write(value.verifiedResponse, into: &buf)
    }
}


public func FfiConverterTypeMDLReaderResponseData_lift(_ buf: RustBuffer) throws -> MdlReaderResponseData {
    return try FfiConverterTypeMDLReaderResponseData.lift(buf)
}

public func FfiConverterTypeMDLReaderResponseData_lower(_ value: MdlReaderResponseData) -> RustBuffer {
    return FfiConverterTypeMDLReaderResponseData.lower(value)
}


public struct MdlReaderSessionData {
    public var state: MdlSessionManager
    public var uuid: Uuid
    public var request: Data
    public var bleIdent: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: MdlSessionManager, uuid: Uuid, request: Data, bleIdent: Data) {
        self.state = state
        self.uuid = uuid
        self.request = request
        self.bleIdent = bleIdent
    }
}



public struct FfiConverterTypeMDLReaderSessionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderSessionData {
        return
            try MdlReaderSessionData(
                state: FfiConverterTypeMDLSessionManager.read(from: &buf), 
                uuid: FfiConverterTypeUuid.read(from: &buf), 
                request: FfiConverterData.read(from: &buf), 
                bleIdent: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: MdlReaderSessionData, into buf: inout [UInt8]) {
        FfiConverterTypeMDLSessionManager.write(value.state, into: &buf)
        FfiConverterTypeUuid.write(value.uuid, into: &buf)
        FfiConverterData.write(value.request, into: &buf)
        FfiConverterData.write(value.bleIdent, into: &buf)
    }
}


public func FfiConverterTypeMDLReaderSessionData_lift(_ buf: RustBuffer) throws -> MdlReaderSessionData {
    return try FfiConverterTypeMDLReaderSessionData.lift(buf)
}

public func FfiConverterTypeMDLReaderSessionData_lower(_ value: MdlReaderSessionData) -> RustBuffer {
    return FfiConverterTypeMDLReaderSessionData.lower(value)
}


public struct StatusMessage {
    /**
     * The value of the entry in the status list
     */
    public var status: UInt8
    /**
     * Message that corresponds the the value.
     */
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The value of the entry in the status list
         */status: UInt8, 
        /**
         * Message that corresponds the the value.
         */message: String) {
        self.status = status
        self.message = message
    }
}



extension StatusMessage: Equatable, Hashable {
    public static func ==(lhs: StatusMessage, rhs: StatusMessage) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(message)
    }
}


public struct FfiConverterTypeStatusMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StatusMessage {
        return
            try StatusMessage(
                status: FfiConverterUInt8.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: StatusMessage, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.status, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


public func FfiConverterTypeStatusMessage_lift(_ buf: RustBuffer) throws -> StatusMessage {
    return try FfiConverterTypeStatusMessage.lift(buf)
}

public func FfiConverterTypeStatusMessage_lower(_ value: StatusMessage) -> RustBuffer {
    return FfiConverterTypeStatusMessage.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Credential claim values.
 */

public enum ClaimValue {
    
    /**
     * Any text claim that doesn't need special formatting.
     */
    case text(value: String
    )
    /**
     * A date claim in the format `[year]-[month]-[day]`.
     */
    case date(value: String
    )
    /**
     * MapArray
     */
    case mapClaim(value: [String: String]
    )
}


public struct FfiConverterTypeClaimValue: FfiConverterRustBuffer {
    typealias SwiftType = ClaimValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .date(value: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .mapClaim(value: try FfiConverterDictionaryStringString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClaimValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .date(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .mapClaim(value):
            writeInt(&buf, Int32(3))
            FfiConverterDictionaryStringString.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeClaimValue_lift(_ buf: RustBuffer) throws -> ClaimValue {
    return try FfiConverterTypeClaimValue.lift(buf)
}

public func FfiConverterTypeClaimValue_lower(_ value: ClaimValue) -> RustBuffer {
    return FfiConverterTypeClaimValue.lower(value)
}



extension ClaimValue: Equatable, Hashable {}




public enum CredentialDecodingError {

    
    
    case MsoMdoc(MdocInitError
    )
    case JsonVc(JsonVcInitError
    )
    case JwtVc(JwtVcInitError
    )
    case SdJwt(SdJwtError
    )
    case UnsupportedCredentialFormat(String
    )
    case Serialization(String
    )
    case Deserialization(String
    )
}


public struct FfiConverterTypeCredentialDecodingError: FfiConverterRustBuffer {
    typealias SwiftType = CredentialDecodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialDecodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MsoMdoc(
            try FfiConverterTypeMdocInitError.read(from: &buf)
            )
        case 2: return .JsonVc(
            try FfiConverterTypeJsonVcInitError.read(from: &buf)
            )
        case 3: return .JwtVc(
            try FfiConverterTypeJwtVcInitError.read(from: &buf)
            )
        case 4: return .SdJwt(
            try FfiConverterTypeSdJwtError.read(from: &buf)
            )
        case 5: return .UnsupportedCredentialFormat(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .Serialization(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .Deserialization(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CredentialDecodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .MsoMdoc(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMdocInitError.write(v1, into: &buf)
            
        
        case let .JsonVc(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeJsonVcInitError.write(v1, into: &buf)
            
        
        case let .JwtVc(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeJwtVcInitError.write(v1, into: &buf)
            
        
        case let .SdJwt(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeSdJwtError.write(v1, into: &buf)
            
        
        case let .UnsupportedCredentialFormat(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Serialization(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Deserialization(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension CredentialDecodingError: Equatable, Hashable {}

extension CredentialDecodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum CredentialEncodingError {

    
    
    case MsoMdoc(MdocEncodingError
    )
    case JsonVc(JsonVcEncodingError
    )
    case SdJwt(SdJwtError
    )
    case VpToken(String
    )
    case Presentation(PresentationError
    )
}


public struct FfiConverterTypeCredentialEncodingError: FfiConverterRustBuffer {
    typealias SwiftType = CredentialEncodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialEncodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MsoMdoc(
            try FfiConverterTypeMdocEncodingError.read(from: &buf)
            )
        case 2: return .JsonVc(
            try FfiConverterTypeJsonVcEncodingError.read(from: &buf)
            )
        case 3: return .SdJwt(
            try FfiConverterTypeSdJwtError.read(from: &buf)
            )
        case 4: return .VpToken(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Presentation(
            try FfiConverterTypePresentationError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CredentialEncodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .MsoMdoc(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMdocEncodingError.write(v1, into: &buf)
            
        
        case let .JsonVc(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeJsonVcEncodingError.write(v1, into: &buf)
            
        
        case let .SdJwt(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeSdJwtError.write(v1, into: &buf)
            
        
        case let .VpToken(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Presentation(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypePresentationError.write(v1, into: &buf)
            
        }
    }
}


extension CredentialEncodingError: Equatable, Hashable {}

extension CredentialEncodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The format of the credential.
 */

public enum CredentialFormat {
    
    case msoMdoc
    case jwtVcJson
    case jwtVcJsonLd
    case ldpVc
    case vcdm2SdJwt
    case other(String
    )
}


public struct FfiConverterTypeCredentialFormat: FfiConverterRustBuffer {
    typealias SwiftType = CredentialFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .msoMdoc
        
        case 2: return .jwtVcJson
        
        case 3: return .jwtVcJsonLd
        
        case 4: return .ldpVc
        
        case 5: return .vcdm2SdJwt
        
        case 6: return .other(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CredentialFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .msoMdoc:
            writeInt(&buf, Int32(1))
        
        
        case .jwtVcJson:
            writeInt(&buf, Int32(2))
        
        
        case .jwtVcJsonLd:
            writeInt(&buf, Int32(3))
        
        
        case .ldpVc:
            writeInt(&buf, Int32(4))
        
        
        case .vcdm2SdJwt:
            writeInt(&buf, Int32(5))
        
        
        case let .other(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeCredentialFormat_lift(_ buf: RustBuffer) throws -> CredentialFormat {
    return try FfiConverterTypeCredentialFormat.lift(buf)
}

public func FfiConverterTypeCredentialFormat_lower(_ value: CredentialFormat) -> RustBuffer {
    return FfiConverterTypeCredentialFormat.lower(value)
}



extension CredentialFormat: Equatable, Hashable {}




public enum CredentialPresentationError {

    
    
    case Decoding(String
    )
    case JsonPath(String
    )
}


public struct FfiConverterTypeCredentialPresentationError: FfiConverterRustBuffer {
    typealias SwiftType = CredentialPresentationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialPresentationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Decoding(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .JsonPath(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CredentialPresentationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Decoding(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .JsonPath(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension CredentialPresentationError: Equatable, Hashable {}

extension CredentialPresentationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DelegatedVerifierStatus {
    
    case initiated
    case pending
    case failure
    case success
}


public struct FfiConverterTypeDelegatedVerifierStatus: FfiConverterRustBuffer {
    typealias SwiftType = DelegatedVerifierStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DelegatedVerifierStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initiated
        
        case 2: return .pending
        
        case 3: return .failure
        
        case 4: return .success
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DelegatedVerifierStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initiated:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case .failure:
            writeInt(&buf, Int32(3))
        
        
        case .success:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeDelegatedVerifierStatus_lift(_ buf: RustBuffer) throws -> DelegatedVerifierStatus {
    return try FfiConverterTypeDelegatedVerifierStatus.lift(buf)
}

public func FfiConverterTypeDelegatedVerifierStatus_lower(_ value: DelegatedVerifierStatus) -> RustBuffer {
    return FfiConverterTypeDelegatedVerifierStatus.lower(value)
}



extension DelegatedVerifierStatus: Equatable, Hashable {}




public enum DidError {

    
    
    case SerializationError(message: String)
    
    case GenerateError(message: String)
    
    case ResolutionError(message: String)
    
    case MissingVerificationMethod(message: String)
    
}


public struct FfiConverterTypeDidError: FfiConverterRustBuffer {
    typealias SwiftType = DidError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DidError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SerializationError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .GenerateError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .ResolutionError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .MissingVerificationMethod(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DidError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .SerializationError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .GenerateError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .ResolutionError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .MissingVerificationMethod(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))

        
        }
    }
}


extension DidError: Equatable, Hashable {}

extension DidError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DidMethod {
    
    case jwk
    case key
}


public struct FfiConverterTypeDidMethod: FfiConverterRustBuffer {
    typealias SwiftType = DidMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DidMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .jwk
        
        case 2: return .key
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DidMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .jwk:
            writeInt(&buf, Int32(1))
        
        
        case .key:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeDidMethod_lift(_ buf: RustBuffer) throws -> DidMethod {
    return try FfiConverterTypeDidMethod.lift(buf)
}

public func FfiConverterTypeDidMethod_lower(_ value: DidMethod) -> RustBuffer {
    return FfiConverterTypeDidMethod.lower(value)
}



extension DidMethod: Equatable, Hashable {}




public enum HttpClientError {

    
    
    case RequestBuilder
    case ResponseBuilder
    case UrlParse
    case MethodParse
    case HeaderParse
    case HeaderKeyParse(key: String
    )
    case HeaderValueParse(value: String
    )
    case HeaderEntryParse(key: String, value: String
    )
    case Other(error: String
    )
}


public struct FfiConverterTypeHttpClientError: FfiConverterRustBuffer {
    typealias SwiftType = HttpClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RequestBuilder
        case 2: return .ResponseBuilder
        case 3: return .UrlParse
        case 4: return .MethodParse
        case 5: return .HeaderParse
        case 6: return .HeaderKeyParse(
            key: try FfiConverterString.read(from: &buf)
            )
        case 7: return .HeaderValueParse(
            value: try FfiConverterString.read(from: &buf)
            )
        case 8: return .HeaderEntryParse(
            key: try FfiConverterString.read(from: &buf), 
            value: try FfiConverterString.read(from: &buf)
            )
        case 9: return .Other(
            error: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HttpClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .RequestBuilder:
            writeInt(&buf, Int32(1))
        
        
        case .ResponseBuilder:
            writeInt(&buf, Int32(2))
        
        
        case .UrlParse:
            writeInt(&buf, Int32(3))
        
        
        case .MethodParse:
            writeInt(&buf, Int32(4))
        
        
        case .HeaderParse:
            writeInt(&buf, Int32(5))
        
        
        case let .HeaderKeyParse(key):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(key, into: &buf)
            
        
        case let .HeaderValueParse(value):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .HeaderEntryParse(key,value):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
            
        
        case let .Other(error):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


extension HttpClientError: Equatable, Hashable {}

extension HttpClientError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum JsonVcEncodingError {

    
    
    case JsonBytesEncoding
}


public struct FfiConverterTypeJsonVcEncodingError: FfiConverterRustBuffer {
    typealias SwiftType = JsonVcEncodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonVcEncodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .JsonBytesEncoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JsonVcEncodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .JsonBytesEncoding:
            writeInt(&buf, Int32(1))
        
        }
    }
}


extension JsonVcEncodingError: Equatable, Hashable {}

extension JsonVcEncodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum JsonVcInitError {

    
    
    case CredentialDecoding
    case CredentialStringEncoding
    case JsonBytesDecoding
    case JsonStringDecoding
}


public struct FfiConverterTypeJsonVcInitError: FfiConverterRustBuffer {
    typealias SwiftType = JsonVcInitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonVcInitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CredentialDecoding
        case 2: return .CredentialStringEncoding
        case 3: return .JsonBytesDecoding
        case 4: return .JsonStringDecoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JsonVcInitError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .CredentialDecoding:
            writeInt(&buf, Int32(1))
        
        
        case .CredentialStringEncoding:
            writeInt(&buf, Int32(2))
        
        
        case .JsonBytesDecoding:
            writeInt(&buf, Int32(3))
        
        
        case .JsonStringDecoding:
            writeInt(&buf, Int32(4))
        
        }
    }
}


extension JsonVcInitError: Equatable, Hashable {}

extension JsonVcInitError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum JwtVcInitError {

    
    
    case CompactJwsDecoding
    case CredentialClaimDecoding
    case CredentialClaimMissing
    case CredentialStringEncoding
    case JwsBytesDecoding
    case JwtDecoding
    case HeaderDecoding
    case PayloadDecoding
}


public struct FfiConverterTypeJwtVcInitError: FfiConverterRustBuffer {
    typealias SwiftType = JwtVcInitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JwtVcInitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CompactJwsDecoding
        case 2: return .CredentialClaimDecoding
        case 3: return .CredentialClaimMissing
        case 4: return .CredentialStringEncoding
        case 5: return .JwsBytesDecoding
        case 6: return .JwtDecoding
        case 7: return .HeaderDecoding
        case 8: return .PayloadDecoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JwtVcInitError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .CompactJwsDecoding:
            writeInt(&buf, Int32(1))
        
        
        case .CredentialClaimDecoding:
            writeInt(&buf, Int32(2))
        
        
        case .CredentialClaimMissing:
            writeInt(&buf, Int32(3))
        
        
        case .CredentialStringEncoding:
            writeInt(&buf, Int32(4))
        
        
        case .JwsBytesDecoding:
            writeInt(&buf, Int32(5))
        
        
        case .JwtDecoding:
            writeInt(&buf, Int32(6))
        
        
        case .HeaderDecoding:
            writeInt(&buf, Int32(7))
        
        
        case .PayloadDecoding:
            writeInt(&buf, Int32(8))
        
        }
    }
}


extension JwtVcInitError: Equatable, Hashable {}

extension JwtVcInitError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum KeyTransformationError {

    
    
    case ToPkcs8(value: String
    )
    case FromPkcs8(value: String
    )
    case FromSec1(value: String
    )
    case ToSec1(value: String
    )
}


public struct FfiConverterTypeKeyTransformationError: FfiConverterRustBuffer {
    typealias SwiftType = KeyTransformationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyTransformationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ToPkcs8(
            value: try FfiConverterString.read(from: &buf)
            )
        case 2: return .FromPkcs8(
            value: try FfiConverterString.read(from: &buf)
            )
        case 3: return .FromSec1(
            value: try FfiConverterString.read(from: &buf)
            )
        case 4: return .ToSec1(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeyTransformationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ToPkcs8(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .FromPkcs8(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .FromSec1(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .ToSec1(value):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension KeyTransformationError: Equatable, Hashable {}

extension KeyTransformationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum MdlReaderResponseError {

    
    
    case InvalidDecryption
    case InvalidParsing
    case InvalidIssuerAuthentication
    case InvalidDeviceAuthentication
    case Generic(value: String
    )
}


public struct FfiConverterTypeMDLReaderResponseError: FfiConverterRustBuffer {
    typealias SwiftType = MdlReaderResponseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderResponseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidDecryption
        case 2: return .InvalidParsing
        case 3: return .InvalidIssuerAuthentication
        case 4: return .InvalidDeviceAuthentication
        case 5: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdlReaderResponseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidDecryption:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidParsing:
            writeInt(&buf, Int32(2))
        
        
        case .InvalidIssuerAuthentication:
            writeInt(&buf, Int32(3))
        
        
        case .InvalidDeviceAuthentication:
            writeInt(&buf, Int32(4))
        
        
        case let .Generic(value):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension MdlReaderResponseError: Equatable, Hashable {}

extension MdlReaderResponseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum MdlReaderSessionError {

    
    
    case Generic(value: String
    )
}


public struct FfiConverterTypeMDLReaderSessionError: FfiConverterRustBuffer {
    typealias SwiftType = MdlReaderSessionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderSessionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdlReaderSessionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension MdlReaderSessionError: Equatable, Hashable {}

extension MdlReaderSessionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MDocItem {
    
    case text(String
    )
    case bool(Bool
    )
    case integer(Int64
    )
    case itemMap([String: MDocItem]
    )
    case array([MDocItem]
    )
}


public struct FfiConverterTypeMDocItem: FfiConverterRustBuffer {
    typealias SwiftType = MDocItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MDocItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .bool(try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .integer(try FfiConverterInt64.read(from: &buf)
        )
        
        case 4: return .itemMap(try FfiConverterDictionaryStringTypeMDocItem.read(from: &buf)
        )
        
        case 5: return .array(try FfiConverterSequenceTypeMDocItem.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MDocItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .bool(v1):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(v1, into: &buf)
            
        
        case let .integer(v1):
            writeInt(&buf, Int32(3))
            FfiConverterInt64.write(v1, into: &buf)
            
        
        case let .itemMap(v1):
            writeInt(&buf, Int32(4))
            FfiConverterDictionaryStringTypeMDocItem.write(v1, into: &buf)
            
        
        case let .array(v1):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeMDocItem.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMDocItem_lift(_ buf: RustBuffer) throws -> MDocItem {
    return try FfiConverterTypeMDocItem.lift(buf)
}

public func FfiConverterTypeMDocItem_lower(_ value: MDocItem) -> RustBuffer {
    return FfiConverterTypeMDocItem.lower(value)
}



extension MDocItem: Equatable, Hashable {}




public enum MdocEncodingError {

    
    
    case DocumentCborEncoding
}


public struct FfiConverterTypeMdocEncodingError: FfiConverterRustBuffer {
    typealias SwiftType = MdocEncodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdocEncodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DocumentCborEncoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdocEncodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .DocumentCborEncoding:
            writeInt(&buf, Int32(1))
        
        }
    }
}


extension MdocEncodingError: Equatable, Hashable {}

extension MdocEncodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum MdocInitError {

    
    
    case DocumentCborDecoding
    case IssuerSignedBase64UrlDecoding
    case IssuerSignedCborDecoding
    case IssuerAuthPayloadMissing
    case IssuerAuthPayloadDecoding
    case KeyAliasMissing
    case NamespacesMissing
    case DocumentUtf8Decoding
}


public struct FfiConverterTypeMdocInitError: FfiConverterRustBuffer {
    typealias SwiftType = MdocInitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdocInitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DocumentCborDecoding
        case 2: return .IssuerSignedBase64UrlDecoding
        case 3: return .IssuerSignedCborDecoding
        case 4: return .IssuerAuthPayloadMissing
        case 5: return .IssuerAuthPayloadDecoding
        case 6: return .KeyAliasMissing
        case 7: return .NamespacesMissing
        case 8: return .DocumentUtf8Decoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdocInitError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .DocumentCborDecoding:
            writeInt(&buf, Int32(1))
        
        
        case .IssuerSignedBase64UrlDecoding:
            writeInt(&buf, Int32(2))
        
        
        case .IssuerSignedCborDecoding:
            writeInt(&buf, Int32(3))
        
        
        case .IssuerAuthPayloadMissing:
            writeInt(&buf, Int32(4))
        
        
        case .IssuerAuthPayloadDecoding:
            writeInt(&buf, Int32(5))
        
        
        case .KeyAliasMissing:
            writeInt(&buf, Int32(6))
        
        
        case .NamespacesMissing:
            writeInt(&buf, Int32(7))
        
        
        case .DocumentUtf8Decoding:
            writeInt(&buf, Int32(8))
        
        }
    }
}


extension MdocInitError: Equatable, Hashable {}

extension MdocInitError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


/**
 * The [OID4VPError] enum represents the errors that can occur
 * when using the oid4vp foreign library.
 */
public enum Oid4vpError {

    
    
    case UnexpectedUniFfiCallbackError(String
    )
    case RequestValidation(String
    )
    case PresentationDefinitionResolution(String
    )
    case Token(String
    )
    case UnsupportedResponseMode(String
    )
    case ResponseSubmission(String
    )
    case CredentialCallback(String
    )
    case PresentationSubmissionCreation(String
    )
    case InvalidDidUrl(String
    )
    case DidKeyGenerateUrl(String
    )
    case JsonSyntaxParse(String
    )
    case VdcCollection(VdcCollectionError
    )
    case HttpClientInitialization(String
    )
    case SigningAlgorithmNotFound(String
    )
    case InvalidClientIdScheme(String
    )
    case InputDescriptorNotFound
    case VpTokenParse(String
    )
    case VpTokenCreate(String
    )
    case JwkParse(String
    )
    case VdcCollectionNotInitialized
    case AuthorizationRequestNotFound
    case RequestSignerNotFound
    case MetadataInitialization(String
    )
    case PermissionRequest(PermissionRequestError
    )
    case Presentation(PresentationError
    )
    case CredentialEncoding(CredentialEncodingError
    )
    case JsonPathParse(String
    )
    case EmptyCredentialSubject(String
    )
}


public struct FfiConverterTypeOID4VPError: FfiConverterRustBuffer {
    typealias SwiftType = Oid4vpError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vpError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .UnexpectedUniFfiCallbackError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .RequestValidation(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .PresentationDefinitionResolution(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .Token(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .UnsupportedResponseMode(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .ResponseSubmission(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .CredentialCallback(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .PresentationSubmissionCreation(
            try FfiConverterString.read(from: &buf)
            )
        case 9: return .InvalidDidUrl(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .DidKeyGenerateUrl(
            try FfiConverterString.read(from: &buf)
            )
        case 11: return .JsonSyntaxParse(
            try FfiConverterString.read(from: &buf)
            )
        case 12: return .VdcCollection(
            try FfiConverterTypeVdcCollectionError.read(from: &buf)
            )
        case 13: return .HttpClientInitialization(
            try FfiConverterString.read(from: &buf)
            )
        case 14: return .SigningAlgorithmNotFound(
            try FfiConverterString.read(from: &buf)
            )
        case 15: return .InvalidClientIdScheme(
            try FfiConverterString.read(from: &buf)
            )
        case 16: return .InputDescriptorNotFound
        case 17: return .VpTokenParse(
            try FfiConverterString.read(from: &buf)
            )
        case 18: return .VpTokenCreate(
            try FfiConverterString.read(from: &buf)
            )
        case 19: return .JwkParse(
            try FfiConverterString.read(from: &buf)
            )
        case 20: return .VdcCollectionNotInitialized
        case 21: return .AuthorizationRequestNotFound
        case 22: return .RequestSignerNotFound
        case 23: return .MetadataInitialization(
            try FfiConverterString.read(from: &buf)
            )
        case 24: return .PermissionRequest(
            try FfiConverterTypePermissionRequestError.read(from: &buf)
            )
        case 25: return .Presentation(
            try FfiConverterTypePresentationError.read(from: &buf)
            )
        case 26: return .CredentialEncoding(
            try FfiConverterTypeCredentialEncodingError.read(from: &buf)
            )
        case 27: return .JsonPathParse(
            try FfiConverterString.read(from: &buf)
            )
        case 28: return .EmptyCredentialSubject(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Oid4vpError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .UnexpectedUniFfiCallbackError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .RequestValidation(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .PresentationDefinitionResolution(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Token(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .UnsupportedResponseMode(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ResponseSubmission(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CredentialCallback(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .PresentationSubmissionCreation(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidDidUrl(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .DidKeyGenerateUrl(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .JsonSyntaxParse(v1):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .VdcCollection(v1):
            writeInt(&buf, Int32(12))
            FfiConverterTypeVdcCollectionError.write(v1, into: &buf)
            
        
        case let .HttpClientInitialization(v1):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SigningAlgorithmNotFound(v1):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidClientIdScheme(v1):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InputDescriptorNotFound:
            writeInt(&buf, Int32(16))
        
        
        case let .VpTokenParse(v1):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .VpTokenCreate(v1):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .JwkParse(v1):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .VdcCollectionNotInitialized:
            writeInt(&buf, Int32(20))
        
        
        case .AuthorizationRequestNotFound:
            writeInt(&buf, Int32(21))
        
        
        case .RequestSignerNotFound:
            writeInt(&buf, Int32(22))
        
        
        case let .MetadataInitialization(v1):
            writeInt(&buf, Int32(23))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .PermissionRequest(v1):
            writeInt(&buf, Int32(24))
            FfiConverterTypePermissionRequestError.write(v1, into: &buf)
            
        
        case let .Presentation(v1):
            writeInt(&buf, Int32(25))
            FfiConverterTypePresentationError.write(v1, into: &buf)
            
        
        case let .CredentialEncoding(v1):
            writeInt(&buf, Int32(26))
            FfiConverterTypeCredentialEncodingError.write(v1, into: &buf)
            
        
        case let .JsonPathParse(v1):
            writeInt(&buf, Int32(27))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .EmptyCredentialSubject(v1):
            writeInt(&buf, Int32(28))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension Oid4vpError: Equatable, Hashable {}

extension Oid4vpError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum Oid4vciError {

    
    
    case SerdeJsonError(message: String)
    
    case RequestError(message: String)
    
    case UnsupportedGrantType(message: String)
    
    case InvalidSession(message: String)
    
    case InvalidParameter(message: String)
    
    case LockError(message: String)
    
    case VpRequestRequired(message: String)
    
    case ProofValidationError(message: String)
    
    case DecodeError(message: String)
    
    case DidError(message: String)
    
    case ContextMapError(message: String)
    
    case Generic(message: String)
    
}


public struct FfiConverterTypeOid4vciError: FfiConverterRustBuffer {
    typealias SwiftType = Oid4vciError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vciError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SerdeJsonError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .RequestError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .UnsupportedGrantType(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidSession(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidParameter(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .LockError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .VpRequestRequired(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .ProofValidationError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .DecodeError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .DidError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .ContextMapError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Oid4vciError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .SerdeJsonError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .RequestError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .UnsupportedGrantType(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .InvalidSession(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvalidParameter(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .LockError(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .VpRequestRequired(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .ProofValidationError(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .DecodeError(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .DidError(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .ContextMapError(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(12))

        
        }
    }
}


extension Oid4vciError: Equatable, Hashable {}

extension Oid4vciError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum Oid4vpVerifierError {

    
    
    case HttpClient(String
    )
    case Url(String
    )
}


public struct FfiConverterTypeOid4vpVerifierError: FfiConverterRustBuffer {
    typealias SwiftType = Oid4vpVerifierError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vpVerifierError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .HttpClient(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Url(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Oid4vpVerifierError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .HttpClient(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Url(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension Oid4vpVerifierError: Equatable, Hashable {}

extension Oid4vpVerifierError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The outcome of attempting to verify a credential.
 */

public enum Outcome {
    
    /**
     * The credential was successfully verified.
     */
    case verified(credentialInfo: CredentialInfo
    )
    /**
     * The credential could not be verified.
     */
    case unverified(credentialInfo: CredentialInfo?, failure: Failure
    )
}


public struct FfiConverterTypeOutcome: FfiConverterRustBuffer {
    typealias SwiftType = Outcome

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Outcome {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .verified(credentialInfo: try FfiConverterTypeCredentialInfo.read(from: &buf)
        )
        
        case 2: return .unverified(credentialInfo: try FfiConverterOptionTypeCredentialInfo.read(from: &buf), failure: try FfiConverterTypeFailure.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Outcome, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .verified(credentialInfo):
            writeInt(&buf, Int32(1))
            FfiConverterTypeCredentialInfo.write(credentialInfo, into: &buf)
            
        
        case let .unverified(credentialInfo,failure):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeCredentialInfo.write(credentialInfo, into: &buf)
            FfiConverterTypeFailure.write(failure, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOutcome_lift(_ buf: RustBuffer) throws -> Outcome {
    return try FfiConverterTypeOutcome.lift(buf)
}

public func FfiConverterTypeOutcome_lower(_ value: Outcome) -> RustBuffer {
    return FfiConverterTypeOutcome.lower(value)
}



extension Outcome: Equatable, Hashable {}




public enum PermissionRequestError {

    
    
    /**
     * Permission denied for requested presentation.
     */
    case PermissionDenied
    /**
     * Credential not found for input descriptor id.
     */
    case CredentialNotFound(String
    )
    /**
     * Input descriptor not found for input descriptor id.
     */
    case InputDescriptorNotFound(String
    )
    /**
     * Invalid selected credential for requested field. Selected
     * credential does not match optional credentials.
     */
    case InvalidSelectedCredential(String,String
    )
    /**
     * Credential Presentation Error
     *
     * failed to present the credential.
     */
    case CredentialPresentation(String
    )
    case RwLock(String
    )
    case PresentationSigning(String
    )
    case CryptographicSuite(String
    )
    case VerificationMethod(String
    )
    case Presentation(PresentationError
    )
}


public struct FfiConverterTypePermissionRequestError: FfiConverterRustBuffer {
    typealias SwiftType = PermissionRequestError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PermissionRequestError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .PermissionDenied
        case 2: return .CredentialNotFound(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InputDescriptorNotFound(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .InvalidSelectedCredential(
            try FfiConverterString.read(from: &buf), 
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .CredentialPresentation(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .RwLock(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .PresentationSigning(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .CryptographicSuite(
            try FfiConverterString.read(from: &buf)
            )
        case 9: return .VerificationMethod(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .Presentation(
            try FfiConverterTypePresentationError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PermissionRequestError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .PermissionDenied:
            writeInt(&buf, Int32(1))
        
        
        case let .CredentialNotFound(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InputDescriptorNotFound(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidSelectedCredential(v1,v2):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            FfiConverterString.write(v2, into: &buf)
            
        
        case let .CredentialPresentation(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .RwLock(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .PresentationSigning(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CryptographicSuite(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .VerificationMethod(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Presentation(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypePresentationError.write(v1, into: &buf)
            
        }
    }
}


extension PermissionRequestError: Equatable, Hashable {}

extension PermissionRequestError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum PopError {

    
    
    case DidError(message: String)
    
    case UrlParseError(message: String)
    
    case DidUrlParseError(message: String)
    
    case SerializationError(message: String)
    
    case ConversionError(message: String)
    
}


public struct FfiConverterTypePopError: FfiConverterRustBuffer {
    typealias SwiftType = PopError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PopError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DidError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .UrlParseError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .DidUrlParseError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .SerializationError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .ConversionError(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PopError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .DidError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .UrlParseError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .DidUrlParseError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .SerializationError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .ConversionError(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))

        
        }
    }
}


extension PopError: Equatable, Hashable {}

extension PopError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum PresentationError {

    
    
    case Signing(String
    )
    case CryptographicSuite(String
    )
    case VerificationMethod(String
    )
    case Context(String
    )
    case Jwk(String
    )
}


public struct FfiConverterTypePresentationError: FfiConverterRustBuffer {
    typealias SwiftType = PresentationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PresentationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Signing(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .CryptographicSuite(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .VerificationMethod(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .Context(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Jwk(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PresentationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Signing(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CryptographicSuite(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .VerificationMethod(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Context(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Jwk(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension PresentationError: Equatable, Hashable {}

extension PresentationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum RequestError {

    
    
    case Generic(value: String
    )
}


public struct FfiConverterTypeRequestError: FfiConverterRustBuffer {
    typealias SwiftType = RequestError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension RequestError: Equatable, Hashable {}

extension RequestError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum ResponseError {

    
    
    case MissingSignature
    case Generic(value: String
    )
}


public struct FfiConverterTypeResponseError: FfiConverterRustBuffer {
    typealias SwiftType = ResponseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResponseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingSignature
        case 2: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResponseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .MissingSignature:
            writeInt(&buf, Int32(1))
        
        
        case let .Generic(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension ResponseError: Equatable, Hashable {}

extension ResponseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum SdJwtError {

    
    
    case SdJwtVcInitError(String
    )
    case SdJwtDecoding(String
    )
    case InvalidSdJwt(String
    )
    case Serialization(String
    )
    case CredentialEncoding(String
    )
    case CredentialClaimMissing
}


public struct FfiConverterTypeSdJwtError: FfiConverterRustBuffer {
    typealias SwiftType = SdJwtError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdJwtError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SdJwtVcInitError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .SdJwtDecoding(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidSdJwt(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .Serialization(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .CredentialEncoding(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .CredentialClaimMissing

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdJwtError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SdJwtVcInitError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SdJwtDecoding(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidSdJwt(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Serialization(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CredentialEncoding(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .CredentialClaimMissing:
            writeInt(&buf, Int32(6))
        
        }
    }
}


extension SdJwtError: Equatable, Hashable {}

extension SdJwtError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum SessionError {

    
    
    case Generic(value: String
    )
}


public struct FfiConverterTypeSessionError: FfiConverterRustBuffer {
    typealias SwiftType = SessionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SessionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension SessionError: Equatable, Hashable {}

extension SessionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum SignatureError {

    
    
    case InvalidSignature(value: String
    )
    case TooManyDocuments
    case Generic(value: String
    )
}


public struct FfiConverterTypeSignatureError: FfiConverterRustBuffer {
    typealias SwiftType = SignatureError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidSignature(
            value: try FfiConverterString.read(from: &buf)
            )
        case 2: return .TooManyDocuments
        case 3: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidSignature(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case .TooManyDocuments:
            writeInt(&buf, Int32(2))
        
        
        case let .Generic(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension SignatureError: Equatable, Hashable {}

extension SignatureError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum StatusListError {

    
    
    case Resolution(String
    )
    case UnsupportedCredentialFormat
}


public struct FfiConverterTypeStatusListError: FfiConverterRustBuffer {
    typealias SwiftType = StatusListError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StatusListError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Resolution(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .UnsupportedCredentialFormat

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StatusListError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Resolution(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .UnsupportedCredentialFormat:
            writeInt(&buf, Int32(2))
        
        }
    }
}


extension StatusListError: Equatable, Hashable {}

extension StatusListError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


/**
 * Enum: StorageManagerError
 *
 * Represents errors that may occur during storage management operations
 */
public enum StorageManagerError {

    
    
    /**
     * This error happens when the key value could not be used with the underlying
     * storage system on the device
     */
    case InvalidLookupKey
    /**
     * This error occurrs when we can retrieve a value, but could not decrypt it
     */
    case CouldNotDecryptValue
    /**
     * The underlying device has no more storage available
     */
    case StorageFull
    /**
     * During storage manager initialization, it must create a new encryption key.  This
     * error is raised when that key could not be created.
     */
    case CouldNotMakeKey
    /**
     * An internal problem occurred in the storage manager.
     */
    case InternalError
}


public struct FfiConverterTypeStorageManagerError: FfiConverterRustBuffer {
    typealias SwiftType = StorageManagerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageManagerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidLookupKey
        case 2: return .CouldNotDecryptValue
        case 3: return .StorageFull
        case 4: return .CouldNotMakeKey
        case 5: return .InternalError

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StorageManagerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidLookupKey:
            writeInt(&buf, Int32(1))
        
        
        case .CouldNotDecryptValue:
            writeInt(&buf, Int32(2))
        
        
        case .StorageFull:
            writeInt(&buf, Int32(3))
        
        
        case .CouldNotMakeKey:
            writeInt(&buf, Int32(4))
        
        
        case .InternalError:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension StorageManagerError: Equatable, Hashable {}

extension StorageManagerError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum TerminationError {

    
    
    case Generic(value: String
    )
}


public struct FfiConverterTypeTerminationError: FfiConverterRustBuffer {
    typealias SwiftType = TerminationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TerminationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TerminationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension TerminationError: Equatable, Hashable {}

extension TerminationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum VcbVerificationError {

    
    
    case Generic(value: String
    )
    case Verification
}


public struct FfiConverterTypeVCBVerificationError: FfiConverterRustBuffer {
    typealias SwiftType = VcbVerificationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VcbVerificationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Verification

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VcbVerificationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case .Verification:
            writeInt(&buf, Int32(2))
        
        }
    }
}


extension VcbVerificationError: Equatable, Hashable {}

extension VcbVerificationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum VcVerificationError {

    
    
    case Generic(value: String
    )
}


public struct FfiConverterTypeVCVerificationError: FfiConverterRustBuffer {
    typealias SwiftType = VcVerificationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VcVerificationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VcVerificationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension VcVerificationError: Equatable, Hashable {}

extension VcVerificationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum VpError {

    
    
    case Verification
    case Signing
    case Parsing(value: String
    )
    case Generic(value: String
    )
}


public struct FfiConverterTypeVPError: FfiConverterRustBuffer {
    typealias SwiftType = VpError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VpError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Verification
        case 2: return .Signing
        case 3: return .Parsing(
            value: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VpError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Verification:
            writeInt(&buf, Int32(1))
        
        
        case .Signing:
            writeInt(&buf, Int32(2))
        
        
        case let .Parsing(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .Generic(value):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension VpError: Equatable, Hashable {}

extension VpError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VcdmVersion {
    
    case v1
    case v2
}


public struct FfiConverterTypeVcdmVersion: FfiConverterRustBuffer {
    typealias SwiftType = VcdmVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VcdmVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v1
        
        case 2: return .v2
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VcdmVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v1:
            writeInt(&buf, Int32(1))
        
        
        case .v2:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeVcdmVersion_lift(_ buf: RustBuffer) throws -> VcdmVersion {
    return try FfiConverterTypeVcdmVersion.lift(buf)
}

public func FfiConverterTypeVcdmVersion_lower(_ value: VcdmVersion) -> RustBuffer {
    return FfiConverterTypeVcdmVersion.lower(value)
}



extension VcdmVersion: Equatable, Hashable {}




public enum VdcCollectionError {

    
    
    /**
     * Attempt to convert the credential to a serialized form suitable for writing to storage failed.
     */
    case SerializeFailed
    /**
     * Attempting to convert the credential to a deserialized form suitable for runtime use failed.
     */
    case DeserializeFailed
    /**
     * Attempting to write the credential to storage failed.
     */
    case StoreFailed(StorageManagerError
    )
    /**
     * Attempting to read the credential from storage failed.
     */
    case LoadFailed(StorageManagerError
    )
    /**
     * Attempting to delete a credential from storage failed.
     */
    case DeleteFailed(StorageManagerError
    )
}


public struct FfiConverterTypeVdcCollectionError: FfiConverterRustBuffer {
    typealias SwiftType = VdcCollectionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VdcCollectionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SerializeFailed
        case 2: return .DeserializeFailed
        case 3: return .StoreFailed(
            try FfiConverterTypeStorageManagerError.read(from: &buf)
            )
        case 4: return .LoadFailed(
            try FfiConverterTypeStorageManagerError.read(from: &buf)
            )
        case 5: return .DeleteFailed(
            try FfiConverterTypeStorageManagerError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VdcCollectionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .SerializeFailed:
            writeInt(&buf, Int32(1))
        
        
        case .DeserializeFailed:
            writeInt(&buf, Int32(2))
        
        
        case let .StoreFailed(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeStorageManagerError.write(v1, into: &buf)
            
        
        case let .LoadFailed(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeStorageManagerError.write(v1, into: &buf)
            
        
        case let .DeleteFailed(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeStorageManagerError.write(v1, into: &buf)
            
        }
    }
}


extension VdcCollectionError: Equatable, Hashable {}

extension VdcCollectionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VerificationResult {
    
    case success
    case failure(cause: String
    )
}


public struct FfiConverterTypeVerificationResult: FfiConverterRustBuffer {
    typealias SwiftType = VerificationResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerificationResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .success
        
        case 2: return .failure(cause: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerificationResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case .success:
            writeInt(&buf, Int32(1))
        
        
        case let .failure(cause):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(cause, into: &buf)
            
        }
    }
}


public func FfiConverterTypeVerificationResult_lift(_ buf: RustBuffer) throws -> VerificationResult {
    return try FfiConverterTypeVerificationResult.lift(buf)
}

public func FfiConverterTypeVerificationResult_lower(_ value: VerificationResult) -> RustBuffer {
    return FfiConverterTypeVerificationResult.lower(value)
}



extension VerificationResult: Equatable, Hashable {}






/**
 * The `PresentationSigner` foreign callback interface to be implemented
 * by the host environment, e.g. Kotlin or Swift.
 *
 * Signing is handled after the authorization request is reviewed and authorized
 * and the credentials for presentation have been selected.
 *
 * The payload for signing is determined by the credential format and the encoding
 * type of the `vp_token`.
 *
 * For example, in the case of `JwtVc` credential format,
 * the signing payload consists of the JWT header and payload (JWS).
 */
public protocol PresentationSigner : AnyObject {
    
    /**
     * Sign the payload with the private key and return the signature.
     *
     * The signing algorithm must match the `cryptosuite()` method result.
     */
    func sign(payload: Data) async throws  -> Data
    
    /**
     * Return the algorithm used for signing the vp token.
     *
     * E.g., "ES256"
     */
    func algorithm()  -> Algorithm
    
    /**
     * Return the verification method associated with the signing key.
     */
    func verificationMethod() async  -> String
    
    /**
     * Return the `DID` of the signing key.
     */
    func did()  -> String
    
    /**
     * Data Integrity Cryptographic Suite of the Signer.
     *
     * This corresponds to the `proof_type` in the
     * authorization request corresponding to the
     * format of the verifiable presentation, e.g,
     * `ldp_vp`, `jwt_vp`.
     *
     *
     * E.g., JsonWebSignature2020, ecdsa-rdfc-2019
     */
    func cryptosuite()  -> CryptosuiteString
    
    /**
     * Return the public JWK of the signing key.
     * as a String-encoded JSON
     */
    func jwk()  -> String
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePresentationSigner {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfacePresentationSigner = UniffiVTableCallbackInterfacePresentationSigner(
        sign: { (
            uniffiHandle: UInt64,
            payload: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Data in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.sign(
                     payload: try FfiConverterData.lift(payload)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Data) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterData.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypePresentationError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        algorithm: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Algorithm in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.algorithm(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeAlgorithm.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        verificationMethod: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.verificationMethod(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        did: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.did(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        cryptosuite: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> CryptosuiteString in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.cryptosuite(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeCryptosuiteString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        jwk: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.jwk(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface PresentationSigner: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitPresentationSigner() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_presentationsigner(&UniffiCallbackInterfacePresentationSigner.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfacePresentationSigner {
    fileprivate static var handleMap = UniffiHandleMap<PresentationSigner>()
}

extension FfiConverterCallbackInterfacePresentationSigner : FfiConverter {
    typealias SwiftType = PresentationSigner
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeJsonVc: FfiConverterRustBuffer {
    typealias SwiftType = JsonVc?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJsonVc.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJsonVc.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeJwtVc: FfiConverterRustBuffer {
    typealias SwiftType = JwtVc?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJwtVc.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJwtVc.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMdoc: FfiConverterRustBuffer {
    typealias SwiftType = Mdoc?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMdoc.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMdoc.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVCDM2SdJwt: FfiConverterRustBuffer {
    typealias SwiftType = Vcdm2SdJwt?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVCDM2SdJwt.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVCDM2SdJwt.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCredential: FfiConverterRustBuffer {
    typealias SwiftType = Credential?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCredential.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCredential.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCredentialInfo: FfiConverterRustBuffer {
    typealias SwiftType = CredentialInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCredentialInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCredentialInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDelegatedVerifierOid4vpResponse: FfiConverterRustBuffer {
    typealias SwiftType = DelegatedVerifierOid4vpResponse?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDelegatedVerifierOid4vpResponse.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDelegatedVerifierOid4vpResponse.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryStringString: FfiConverterRustBuffer {
    typealias SwiftType = [String: String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeKeyAlias: FfiConverterRustBuffer {
    typealias SwiftType = KeyAlias?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeKeyAlias.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeKeyAlias.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUrl: FfiConverterRustBuffer {
    typealias SwiftType = Url?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUrl.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUrl.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeValue: FfiConverterRustBuffer {
    typealias SwiftType = Value?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeParsedCredential: FfiConverterRustBuffer {
    typealias SwiftType = [ParsedCredential]

    public static func write(_ value: [ParsedCredential], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeParsedCredential.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ParsedCredential] {
        let len: Int32 = try readInt(&buf)
        var seq = [ParsedCredential]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeParsedCredential.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRequestedField: FfiConverterRustBuffer {
    typealias SwiftType = [RequestedField]

    public static func write(_ value: [RequestedField], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequestedField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RequestedField] {
        let len: Int32 = try readInt(&buf)
        var seq = [RequestedField]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequestedField.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCredentialResponse: FfiConverterRustBuffer {
    typealias SwiftType = [CredentialResponse]

    public static func write(_ value: [CredentialResponse], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCredentialResponse.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CredentialResponse] {
        let len: Int32 = try readInt(&buf)
        var seq = [CredentialResponse]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCredentialResponse.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeElement: FfiConverterRustBuffer {
    typealias SwiftType = [Element]

    public static func write(_ value: [Element], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeElement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Element] {
        let len: Int32 = try readInt(&buf)
        var seq = [Element]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeElement.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeItemsRequest: FfiConverterRustBuffer {
    typealias SwiftType = [ItemsRequest]

    public static func write(_ value: [ItemsRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeItemsRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ItemsRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [ItemsRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeItemsRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeStatusMessage: FfiConverterRustBuffer {
    typealias SwiftType = [StatusMessage]

    public static func write(_ value: [StatusMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStatusMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [StatusMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [StatusMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeStatusMessage.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMDocItem: FfiConverterRustBuffer {
    typealias SwiftType = [MDocItem]

    public static func write(_ value: [MDocItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMDocItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MDocItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [MDocItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMDocItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeKey: FfiConverterRustBuffer {
    typealias SwiftType = [Key]

    public static func write(_ value: [Key], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Key] {
        let len: Int32 = try readInt(&buf)
        var seq = [Key]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUuid: FfiConverterRustBuffer {
    typealias SwiftType = [Uuid]

    public static func write(_ value: [Uuid], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUuid.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Uuid] {
        let len: Int32 = try readInt(&buf)
        var seq = [Uuid]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUuid.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringBool: FfiConverterRustBuffer {
    public static func write(_ value: [String: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeClaimValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: ClaimValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeClaimValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ClaimValue] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ClaimValue]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeClaimValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeMDocItem: FfiConverterRustBuffer {
    public static func write(_ value: [String: MDocItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeMDocItem.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: MDocItem] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: MDocItem]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeMDocItem.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringBool: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: Bool]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: Bool]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: Bool]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringTypeMDocItem: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: MDocItem]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringTypeMDocItem.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: MDocItem]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: MDocItem]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringTypeMDocItem.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: [String]]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: [String]]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: [String]]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeNamespaceSequenceTypeElement: FfiConverterRustBuffer {
    public static func write(_ value: [Namespace: [Element]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeNamespace.write(key, into: &buf)
            FfiConverterSequenceTypeElement.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Namespace: [Element]] {
        let len: Int32 = try readInt(&buf)
        var dict = [Namespace: [Element]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeNamespace.read(from: &buf)
            let value = try FfiConverterSequenceTypeElement.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Algorithm = String
public struct FfiConverterTypeAlgorithm: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Algorithm {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Algorithm, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Algorithm {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Algorithm) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeAlgorithm_lift(_ value: RustBuffer) throws -> Algorithm {
    return try FfiConverterTypeAlgorithm.lift(value)
}

public func FfiConverterTypeAlgorithm_lower(_ value: Algorithm) -> RustBuffer {
    return FfiConverterTypeAlgorithm.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias CredentialType = String
public struct FfiConverterTypeCredentialType: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialType {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: CredentialType, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> CredentialType {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: CredentialType) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeCredentialType_lift(_ value: RustBuffer) throws -> CredentialType {
    return try FfiConverterTypeCredentialType.lift(value)
}

public func FfiConverterTypeCredentialType_lower(_ value: CredentialType) -> RustBuffer {
    return FfiConverterTypeCredentialType.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias CryptosuiteString = String
public struct FfiConverterTypeCryptosuiteString: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CryptosuiteString {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: CryptosuiteString, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> CryptosuiteString {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: CryptosuiteString) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeCryptosuiteString_lift(_ value: RustBuffer) throws -> CryptosuiteString {
    return try FfiConverterTypeCryptosuiteString.lift(value)
}

public func FfiConverterTypeCryptosuiteString_lower(_ value: CryptosuiteString) -> RustBuffer {
    return FfiConverterTypeCryptosuiteString.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Key = String
public struct FfiConverterTypeKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Key {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Key, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Key {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Key) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeKey_lift(_ value: RustBuffer) throws -> Key {
    return try FfiConverterTypeKey.lift(value)
}

public func FfiConverterTypeKey_lower(_ value: Key) -> RustBuffer {
    return FfiConverterTypeKey.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias KeyAlias = String
public struct FfiConverterTypeKeyAlias: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyAlias {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: KeyAlias, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> KeyAlias {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: KeyAlias) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeKeyAlias_lift(_ value: RustBuffer) throws -> KeyAlias {
    return try FfiConverterTypeKeyAlias.lift(value)
}

public func FfiConverterTypeKeyAlias_lower(_ value: KeyAlias) -> RustBuffer {
    return FfiConverterTypeKeyAlias.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Namespace = String
public struct FfiConverterTypeNamespace: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Namespace {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Namespace, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Namespace {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Namespace) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeNamespace_lift(_ value: RustBuffer) throws -> Namespace {
    return try FfiConverterTypeNamespace.lift(value)
}

public func FfiConverterTypeNamespace_lower(_ value: Namespace) -> RustBuffer {
    return FfiConverterTypeNamespace.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias StatusPurpose = String
public struct FfiConverterTypeStatusPurpose: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StatusPurpose {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: StatusPurpose, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> StatusPurpose {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: StatusPurpose) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeStatusPurpose_lift(_ value: RustBuffer) throws -> StatusPurpose {
    return try FfiConverterTypeStatusPurpose.lift(value)
}

public func FfiConverterTypeStatusPurpose_lower(_ value: StatusPurpose) -> RustBuffer {
    return FfiConverterTypeStatusPurpose.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Url = String
public struct FfiConverterTypeUrl: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Url {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Url, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Url {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Url) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeUrl_lift(_ value: RustBuffer) throws -> Url {
    return try FfiConverterTypeUrl.lift(value)
}

public func FfiConverterTypeUrl_lower(_ value: Url) -> RustBuffer {
    return FfiConverterTypeUrl.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Uuid = String
public struct FfiConverterTypeUuid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Uuid, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Uuid {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Uuid) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeUuid_lift(_ value: RustBuffer) throws -> Uuid {
    return try FfiConverterTypeUuid.lift(value)
}

public func FfiConverterTypeUuid_lower(_ value: Uuid) -> RustBuffer {
    return FfiConverterTypeUuid.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Value = Data
public struct FfiConverterTypeValue: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Value {
        return try FfiConverterData.read(from: &buf)
    }

    public static func write(_ value: Value, into buf: inout [UInt8]) {
        return FfiConverterData.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Value {
        return try FfiConverterData.lift(value)
    }

    public static func lower(_ value: Value) -> RustBuffer {
        return FfiConverterData.lower(value)
    }
}


public func FfiConverterTypeValue_lift(_ value: RustBuffer) throws -> Value {
    return try FfiConverterTypeValue.lift(value)
}

public func FfiConverterTypeValue_lower(_ value: Value) -> RustBuffer {
    return FfiConverterTypeValue.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountMobileSdkRs() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
public func decodeRevealSdJwt(input: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeSdJwtError.lift) {
    uniffi_mobile_sdk_rs_fn_func_decode_reveal_sd_jwt(
        FfiConverterString.lower(input),$0
    )
})
}
public func establishSession(uri: String, requestedItems: [String: [String: Bool]], trustAnchorRegistry: [String]?)throws  -> MdlReaderSessionData {
    return try  FfiConverterTypeMDLReaderSessionData.lift(try rustCallWithError(FfiConverterTypeMDLReaderSessionError.lift) {
    uniffi_mobile_sdk_rs_fn_func_establish_session(
        FfiConverterString.lower(uri),
        FfiConverterDictionaryStringDictionaryStringBool.lower(requestedItems),
        FfiConverterOptionSequenceString.lower(trustAnchorRegistry),$0
    )
})
}
public func generatePopComplete(signingInput: Data, signature: Data)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_func_generate_pop_complete(
        FfiConverterData.lower(signingInput),
        FfiConverterData.lower(signature),$0
    )
})
}
public func generatePopPrepare(audience: String, nonce: String?, didMethod: DidMethod, publicJwk: String, durationInSecs: Int64?)async throws  -> Data {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_generate_pop_prepare(FfiConverterString.lower(audience),FfiConverterOptionString.lower(nonce),FfiConverterTypeDidMethod.lower(didMethod),FfiConverterString.lower(publicJwk),FfiConverterOptionInt64.lower(durationInSecs)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypePopError.lift
        )
}
public func handleResponse(state: MdlSessionManager, response: Data)throws  -> MdlReaderResponseData {
    return try  FfiConverterTypeMDLReaderResponseData.lift(try rustCallWithError(FfiConverterTypeMDLReaderResponseError.lift) {
    uniffi_mobile_sdk_rs_fn_func_handle_response(
        FfiConverterTypeMDLSessionManager.lower(state),
        FfiConverterData.lower(response),$0
    )
})
}
/**
 * Begin the mDL presentation process for the holder when the desired
 * Mdoc is already stored in a [VdcCollection].
 *
 * Initializes the presentation session for an ISO 18013-5 mDL and stores
 * the session state object in the device storage_manager.
 *
 * Arguments:
 * mdoc_id: unique identifier for the credential to present, to be looked up
 * in the VDC collection
 * uuid:    the Bluetooth Low Energy Client Central Mode UUID to be used
 *
 * Returns:
 * A Result, with the `Ok` containing a tuple consisting of an enum representing
 * the state of the presentation, a String containing the QR code URI, and a
 * String containing the BLE ident.

 */
public func initializeMdlPresentation(mdocId: Uuid, uuid: Uuid, storageManager: StorageManagerInterface)throws  -> MdlPresentationSession {
    return try  FfiConverterTypeMdlPresentationSession.lift(try rustCallWithError(FfiConverterTypeSessionError.lift) {
    uniffi_mobile_sdk_rs_fn_func_initialize_mdl_presentation(
        FfiConverterTypeUuid.lower(mdocId),
        FfiConverterTypeUuid.lower(uuid),
        FfiConverterTypeStorageManagerInterface.lower(storageManager),$0
    )
})
}
/**
 * Begin the mDL presentation process for the holder by passing in the credential
 * to be presented in the form of an [Mdoc] object.
 *
 * Initializes the presentation session for an ISO 18013-5 mDL and stores
 * the session state object in the device storage_manager.
 *
 * Arguments:
 * mdoc: the Mdoc to be presented, as an [Mdoc] object
 * uuid: the Bluetooth Low Energy Client Central Mode UUID to be used
 *
 * Returns:
 * A Result, with the `Ok` containing a tuple consisting of an enum representing
 * the state of the presentation, a String containing the QR code URI, and a
 * String containing the BLE ident.

 */
public func initializeMdlPresentationFromBytes(mdoc: Mdoc, uuid: Uuid)throws  -> MdlPresentationSession {
    return try  FfiConverterTypeMdlPresentationSession.lift(try rustCallWithError(FfiConverterTypeSessionError.lift) {
    uniffi_mobile_sdk_rs_fn_func_initialize_mdl_presentation_from_bytes(
        FfiConverterTypeMdoc.lower(mdoc),
        FfiConverterTypeUuid.lower(uuid),$0
    )
})
}
public func oid4vciExchangeCredential(session: Oid4vciSession, proofsOfPossession: [String], contextMap: [String: String]?, httpClient: IHttpClient)async throws  -> [CredentialResponse] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_oid4vci_exchange_credential(FfiConverterTypeOid4vciSession.lower(session),FfiConverterSequenceString.lower(proofsOfPossession),FfiConverterOptionDictionaryStringString.lower(contextMap),FfiConverterTypeIHttpClient.lower(httpClient)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeCredentialResponse.lift,
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
public func oid4vciExchangeToken(session: Oid4vciSession, httpClient: IHttpClient)async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_oid4vci_exchange_token(FfiConverterTypeOid4vciSession.lower(session),FfiConverterTypeIHttpClient.lower(httpClient)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
public func oid4vciGetMetadata(session: Oid4vciSession)throws  -> Oid4vciMetadata {
    return try  FfiConverterTypeOid4vciMetadata.lift(try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_func_oid4vci_get_metadata(
        FfiConverterTypeOid4vciSession.lower(session),$0
    )
})
}
public func oid4vciInitiate(baseUrl: String, clientId: String, redirectUrl: String, httpClient: IHttpClient)async throws  -> Oid4vciSession {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_oid4vci_initiate(FfiConverterString.lower(baseUrl),FfiConverterString.lower(clientId),FfiConverterString.lower(redirectUrl),FfiConverterTypeIHttpClient.lower(httpClient)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeOid4vciSession.lift,
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
public func oid4vciInitiateWithOffer(credentialOffer: String, clientId: String, redirectUrl: String, httpClient: IHttpClient)async throws  -> Oid4vciSession {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_oid4vci_initiate_with_offer(FfiConverterString.lower(credentialOffer),FfiConverterString.lower(clientId),FfiConverterString.lower(redirectUrl),FfiConverterTypeIHttpClient.lower(httpClient)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeOid4vciSession.lift,
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
public func vcToSignedVp(vc: String, keyStr: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_vc_to_signed_vp(FfiConverterString.lower(vc),FfiConverterString.lower(keyStr)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeVPError.lift
        )
}
public func verifyJsonVcString(json: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_verify_json_vc_string(FfiConverterString.lower(json)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVCVerificationError.lift
        )
}
public func verifyJwtVp(jwtVp: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_verify_jwt_vp(FfiConverterString.lower(jwtVp)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVPError.lift
        )
}
public func verifyPdf417Barcode(payload: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_verify_pdf417_barcode(FfiConverterString.lower(payload)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVCBVerificationError.lift
        )
}
public func verifyVcbQrcodeAgainstMrz(mrzPayload: String, qrPayload: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_verify_vcb_qrcode_against_mrz(FfiConverterString.lower(mrzPayload),FfiConverterString.lower(qrPayload)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVCBVerificationError.lift
        )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_mobile_sdk_rs_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_decode_reveal_sd_jwt() != 34951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_establish_session() != 26937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_generate_pop_complete() != 56778) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_generate_pop_prepare() != 54105) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_handle_response() != 43961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_initialize_mdl_presentation() != 53444) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_initialize_mdl_presentation_from_bytes() != 26972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_exchange_credential() != 59343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_exchange_token() != 3394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_get_metadata() != 16967) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_initiate() != 45435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_initiate_with_offer() != 12958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_vc_to_signed_vp() != 47312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verify_json_vc_string() != 13072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verify_jwt_vp() != 8825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verify_pdf417_barcode() != 14164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verify_vcb_qrcode_against_mrz() != 36527) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_asynchttpclient_http_client() != 44924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_delegatedverifier_poll_verification_status() != 35131) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_delegatedverifier_request_delegated_verification() != 37161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_didmethodutils_did_from_jwk() != 55995) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_didmethodutils_vm_from_jwk() != 9065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_holder_authorization_request() != 45396) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_holder_submit_permission_response() != 37701) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_credential_as_json_encoded_utf8_string() != 36585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_id() != 12139) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_key_alias() != 36306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_status() != 56187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_type() != 48063) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_types() != 3171) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_vcdm_version() != 26490) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_credential_as_json_encoded_utf8_string() != 41803) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_id() != 55448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_jws_header_as_json_encoded_utf8_string() != 46211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_jws_payload_as_json_encoded_utf8_string() != 6252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_key_alias() != 13659) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_type() != 41101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_types() != 60467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_vcdm_version() != 26158) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_generate_response() != 37013) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_get_ble_ident() != 25991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_get_qr_code_uri() != 36281) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_handle_request() != 21650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_submit_response() != 684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_terminate_session() != 8677) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdoc_details() != 29355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdoc_doctype() != 46465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdoc_id() != 18877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdoc_key_alias() != 39341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_clear_context_map() != 165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_exchange_credential() != 17336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_exchange_token() != 35585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_get_metadata() != 38460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_initiate() != 12704) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_initiate_logger() != 11448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_initiate_with_offer() != 23294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_set_context_map() != 64024) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_authorization_servers() != 42340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_batch_credential_endpoint() != 60237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_credential_endpoint() != 16138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_deferred_credential_endpoint() != 24938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_issuer() != 28727) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_notification_endpoint() != 39275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_to_json() != 52469) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_as_json_vc() != 62122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_as_jwt_vc() != 38850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_as_mso_mdoc() != 54804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_as_sd_jwt() != 23438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_format() != 39112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_id() != 46894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_into_generic_form() != 30318) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_key_alias() != 52023) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_type() != 60750) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionrequest_create_permission_response() != 16918) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionrequest_credentials() != 38374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionrequest_purpose() != 28780) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionrequest_requested_fields() != 48174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionresponse_selected_credentials() != 47291) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_name() != 19474) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_purpose() != 46977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_raw_fields() != 44847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_required() != 14409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_retained() != 21715) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status_is_message() != 61380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status_is_revoked() != 37392) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status_is_suspended() != 54379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status_messages() != 26217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status_purpose() != 51769) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_storagemanagerinterface_add() != 60217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_storagemanagerinterface_get() != 64957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_storagemanagerinterface_list() != 22654) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_storagemanagerinterface_remove() != 46691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_synchttpclient_http_client() != 53085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vcdm2sdjwt_id() != 13770) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vcdm2sdjwt_key_alias() != 49360) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vcdm2sdjwt_revealed_claims_as_json_string() != 39703) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vcdm2sdjwt_type() != 50079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_add() != 43160) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_all_entries() != 7546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_all_entries_by_type() != 7766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_delete() != 26842) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_dump() != 14663) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_get() != 52546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_delegatedverifier_new_client() != 15415) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_didmethodutils_new() != 22235) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_holder_new() != 64916) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_holder_new_with_credentials() != 28515) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_ihttpclient_new_async() != 55307) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_ihttpclient_new_sync() != 47576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jsonvc_new_from_json() != 40674) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jsonvc_new_from_json_with_key() != 63463) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jwtvc_new_from_compact_jws() != 5193) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jwtvc_new_from_compact_jws_with_key() != 27338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_mdoc_from_cbor_encoded_document() != 32979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_mdoc_from_stringified_document() != 58042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_mdoc_new_from_base64url_encoded_issuer_signed() != 17520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new() != 27200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new_with_async_client() != 57260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new_with_default_async_client() != 51040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new_with_default_sync_client() != 30492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new_with_sync_client() != 31928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_from_json() != 1837) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_jwt_vc_json() != 56340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_jwt_vc_json_ld() != 46832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_ldp_vc() != 45177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_mso_mdoc() != 58058) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_sd_jwt() != 34266) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_parse_from_credential() != 15018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_vcdm2sdjwt_new_from_compact_sd_jwt() != 56155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_vcdm2sdjwt_new_from_compact_sd_jwt_with_key() != 15244) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_vdccollection_new() != 31236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentationsigner_sign() != 27180) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentationsigner_algorithm() != 48923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentationsigner_verification_method() != 21787) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentationsigner_did() != 14569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentationsigner_cryptosuite() != 63070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentationsigner_jwk() != 12828) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitAsyncHttpClient()
    uniffiCallbackInitStorageManagerInterface()
    uniffiCallbackInitSyncHttpClient()
    uniffiCallbackInitPresentationSigner()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all