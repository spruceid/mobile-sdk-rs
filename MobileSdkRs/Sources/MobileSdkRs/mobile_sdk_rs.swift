// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(mobile_sdk_rsFFI)
import mobile_sdk_rsFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_mobile_sdk_rs_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_mobile_sdk_rs_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol AsyncHttpClient : AnyObject {
    
    func httpClient(request: HttpRequest) async throws  -> HttpResponse
    
}

open class AsyncHttpClientImpl:
    AsyncHttpClient {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_asynchttpclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_asynchttpclient(pointer, $0) }
    }

    

    
open func httpClient(request: HttpRequest)async throws  -> HttpResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_asynchttpclient_http_client(
                    self.uniffiClonePointer(),
                    FfiConverterTypeHttpRequest.lower(request)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeHttpResponse.lift,
            errorHandler: FfiConverterTypeHttpClientError.lift
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceAsyncHttpClient {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceAsyncHttpClient = UniffiVTableCallbackInterfaceAsyncHttpClient(
        httpClient: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> HttpResponse in
                guard let uniffiObj = try? FfiConverterTypeAsyncHttpClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.httpClient(
                     request: try FfiConverterTypeHttpRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: HttpResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeHttpResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeHttpClientError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeAsyncHttpClient.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface AsyncHttpClient: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitAsyncHttpClient() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_asynchttpclient(&UniffiCallbackInterfaceAsyncHttpClient.vtable)
}

public struct FfiConverterTypeAsyncHttpClient: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<AsyncHttpClient>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AsyncHttpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AsyncHttpClient {
        return AsyncHttpClientImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AsyncHttpClient) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AsyncHttpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AsyncHttpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeAsyncHttpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> AsyncHttpClient {
    return try FfiConverterTypeAsyncHttpClient.lift(pointer)
}

public func FfiConverterTypeAsyncHttpClient_lower(_ value: AsyncHttpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAsyncHttpClient.lower(value)
}




public protocol ClientProtocol : AnyObject {
    
}

open class Client:
    ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_client(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_client(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}




public protocol CredentialIssuerMetadataProtocol : AnyObject {
    
}

open class CredentialIssuerMetadata:
    CredentialIssuerMetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_credentialissuermetadata(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_credentialissuermetadata(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeCredentialIssuerMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CredentialIssuerMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CredentialIssuerMetadata {
        return CredentialIssuerMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CredentialIssuerMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialIssuerMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CredentialIssuerMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeCredentialIssuerMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> CredentialIssuerMetadata {
    return try FfiConverterTypeCredentialIssuerMetadata.lift(pointer)
}

public func FfiConverterTypeCredentialIssuerMetadata_lower(_ value: CredentialIssuerMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCredentialIssuerMetadata.lower(value)
}




public protocol CredentialRequestProtocol : AnyObject {
    
}

open class CredentialRequest:
    CredentialRequestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_credentialrequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_credentialrequest(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeCredentialRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CredentialRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CredentialRequest {
        return CredentialRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CredentialRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CredentialRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeCredentialRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> CredentialRequest {
    return try FfiConverterTypeCredentialRequest.lift(pointer)
}

public func FfiConverterTypeCredentialRequest_lower(_ value: CredentialRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCredentialRequest.lower(value)
}




public protocol GrantsProtocol : AnyObject {
    
}

open class Grants:
    GrantsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_grants(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_grants(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeGrants: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Grants

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Grants {
        return Grants(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Grants) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Grants {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Grants, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeGrants_lift(_ pointer: UnsafeMutableRawPointer) throws -> Grants {
    return try FfiConverterTypeGrants.lift(pointer)
}

public func FfiConverterTypeGrants_lower(_ value: Grants) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGrants.lower(value)
}




/**
 * Http client wrapper type that could either be a synchronous or asynchronous
 * external (Kotlin, Swift, etc) client implementation, receveid as a dynamic
 * trait implementation reference (`Arc<dyn (As|S)yncHttpClient`).
 *
 * `Arc` is wrapped with `IArc` to facilitate trait implementation from
 * `openidconnect` library used by request builders and client on `oid4vci-rs`.
 */
public protocol IHttpClientProtocol : AnyObject {
    
}

/**
 * Http client wrapper type that could either be a synchronous or asynchronous
 * external (Kotlin, Swift, etc) client implementation, receveid as a dynamic
 * trait implementation reference (`Arc<dyn (As|S)yncHttpClient`).
 *
 * `Arc` is wrapped with `IArc` to facilitate trait implementation from
 * `openidconnect` library used by request builders and client on `oid4vci-rs`.
 */
open class IHttpClient:
    IHttpClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_ihttpclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_ihttpclient(pointer, $0) }
    }

    
public static func newAsync(clientImpl: AsyncHttpClient) -> IHttpClient {
    return try!  FfiConverterTypeIHttpClient.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_ihttpclient_new_async(
        FfiConverterTypeAsyncHttpClient.lower(clientImpl),$0
    )
})
}
    
public static func newSync(clientImpl: SyncHttpClient) -> IHttpClient {
    return try!  FfiConverterTypeIHttpClient.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_ihttpclient_new_sync(
        FfiConverterTypeSyncHttpClient.lower(clientImpl),$0
    )
})
}
    

    

}

public struct FfiConverterTypeIHttpClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = IHttpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> IHttpClient {
        return IHttpClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: IHttpClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IHttpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: IHttpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeIHttpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> IHttpClient {
    return try FfiConverterTypeIHttpClient.lift(pointer)
}

public func FfiConverterTypeIHttpClient_lower(_ value: IHttpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIHttpClient.lower(value)
}




public protocol InProcessRecordProtocol : AnyObject {
    
}

open class InProcessRecord:
    InProcessRecordProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_inprocessrecord(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_inprocessrecord(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeInProcessRecord: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = InProcessRecord

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> InProcessRecord {
        return InProcessRecord(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: InProcessRecord) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InProcessRecord {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: InProcessRecord, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeInProcessRecord_lift(_ pointer: UnsafeMutableRawPointer) throws -> InProcessRecord {
    return try FfiConverterTypeInProcessRecord.lift(pointer)
}

public func FfiConverterTypeInProcessRecord_lower(_ value: InProcessRecord) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInProcessRecord.lower(value)
}




/**
 * A verifiable credential secured as JSON.
 */
public protocol JsonVcProtocol : AnyObject {
    
    /**
     * Access the W3C VCDM credential as a JSON encoded UTF-8 string.
     */
    func credentialAsJsonEncodedUtf8String()  -> String
    
    /**
     * The local ID of this credential.
     */
    func id()  -> Uuid
    
    /**
     * The keypair identified in the credential for use in a verifiable presentation.
     */
    func keyAlias()  -> KeyAlias?
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
    func type()  -> CredentialType
    
    /**
     * The types of the credential from the VCDM, excluding the base `VerifiableCredential` type.
     */
    func types()  -> [String]
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
    func vcdmVersion()  -> VcdmVersion
    
}

/**
 * A verifiable credential secured as JSON.
 */
open class JsonVc:
    JsonVcProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_jsonvc(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_jsonvc(pointer, $0) }
    }

    
    /**
     * Construct a new credential from UTF-8 encoded JSON.
     */
public static func newFromJson(utf8JsonString: String)throws  -> JsonVc {
    return try  FfiConverterTypeJsonVc.lift(try rustCallWithError(FfiConverterTypeJsonVcInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_jsonvc_new_from_json(
        FfiConverterString.lower(utf8JsonString),$0
    )
})
}
    
    /**
     * Construct a new credential from UTF-8 encoded JSON.
     */
public static func newFromJsonWithKey(utf8JsonString: String, keyAlias: KeyAlias)throws  -> JsonVc {
    return try  FfiConverterTypeJsonVc.lift(try rustCallWithError(FfiConverterTypeJsonVcInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_jsonvc_new_from_json_with_key(
        FfiConverterString.lower(utf8JsonString),
        FfiConverterTypeKeyAlias.lower(keyAlias),$0
    )
})
}
    

    
    /**
     * Access the W3C VCDM credential as a JSON encoded UTF-8 string.
     */
open func credentialAsJsonEncodedUtf8String() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_credential_as_json_encoded_utf8_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The local ID of this credential.
     */
open func id() -> Uuid {
    return try!  FfiConverterTypeUuid.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The keypair identified in the credential for use in a verifiable presentation.
     */
open func keyAlias() -> KeyAlias? {
    return try!  FfiConverterOptionTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
open func type() -> CredentialType {
    return try!  FfiConverterTypeCredentialType.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_type(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The types of the credential from the VCDM, excluding the base `VerifiableCredential` type.
     */
open func types() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_types(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
open func vcdmVersion() -> VcdmVersion {
    return try!  FfiConverterTypeVcdmVersion.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_vcdm_version(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeJsonVc: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = JsonVc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> JsonVc {
        return JsonVc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: JsonVc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonVc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: JsonVc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeJsonVc_lift(_ pointer: UnsafeMutableRawPointer) throws -> JsonVc {
    return try FfiConverterTypeJsonVc.lift(pointer)
}

public func FfiConverterTypeJsonVc_lower(_ value: JsonVc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeJsonVc.lower(value)
}




/**
 * A verifiable credential secured as a JWT.
 */
public protocol JwtVcProtocol : AnyObject {
    
    /**
     * Access the W3C VCDM credential as a JSON encoded UTF-8 string.
     */
    func credentialAsJsonEncodedUtf8String()  -> String
    
    /**
     * The VdcCollection ID for this credential.
     */
    func id()  -> Uuid
    
    /**
     * Access the JWS header as a JSON encoded UTF-8 string.
     */
    func jwsHeaderAsJsonEncodedUtf8String()  -> String
    
    /**
     * Access the JWS payload as a JSON encoded UTF-8 string.
     */
    func jwsPayloadAsJsonEncodedUtf8String()  -> String
    
    /**
     * The keypair identified in the credential for use in a verifiable presentation.
     */
    func keyAlias()  -> KeyAlias?
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
    func type()  -> CredentialType
    
    /**
     * The types of the credential from the VCDM, excluding the base `VerifiableCredential` type.
     */
    func types()  -> [String]
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
    func vcdmVersion()  -> VcdmVersion
    
}

/**
 * A verifiable credential secured as a JWT.
 */
open class JwtVc:
    JwtVcProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_jwtvc(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_jwtvc(pointer, $0) }
    }

    
    /**
     * Construct a new credential from a compact JWS (of the form
     * `<base64-encoded-header>.<base64-encoded-payload>.<base64-encoded-signature>`),
     * without an associated keypair.
     */
public static func newFromCompactJws(jws: String)throws  -> JwtVc {
    return try  FfiConverterTypeJwtVc.lift(try rustCallWithError(FfiConverterTypeJwtVcInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_jwtvc_new_from_compact_jws(
        FfiConverterString.lower(jws),$0
    )
})
}
    
    /**
     * Construct a new credential from a compact JWS (of the form
     * `<base64-encoded-header>.<base64-encoded-payload>.<base64-encoded-signature>`),
     * with an associated keypair.
     */
public static func newFromCompactJwsWithKey(jws: String, keyAlias: KeyAlias)throws  -> JwtVc {
    return try  FfiConverterTypeJwtVc.lift(try rustCallWithError(FfiConverterTypeJwtVcInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_jwtvc_new_from_compact_jws_with_key(
        FfiConverterString.lower(jws),
        FfiConverterTypeKeyAlias.lower(keyAlias),$0
    )
})
}
    

    
    /**
     * Access the W3C VCDM credential as a JSON encoded UTF-8 string.
     */
open func credentialAsJsonEncodedUtf8String() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_credential_as_json_encoded_utf8_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The VdcCollection ID for this credential.
     */
open func id() -> Uuid {
    return try!  FfiConverterTypeUuid.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Access the JWS header as a JSON encoded UTF-8 string.
     */
open func jwsHeaderAsJsonEncodedUtf8String() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_jws_header_as_json_encoded_utf8_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Access the JWS payload as a JSON encoded UTF-8 string.
     */
open func jwsPayloadAsJsonEncodedUtf8String() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_jws_payload_as_json_encoded_utf8_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The keypair identified in the credential for use in a verifiable presentation.
     */
open func keyAlias() -> KeyAlias? {
    return try!  FfiConverterOptionTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
open func type() -> CredentialType {
    return try!  FfiConverterTypeCredentialType.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_type(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The types of the credential from the VCDM, excluding the base `VerifiableCredential` type.
     */
open func types() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_types(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
open func vcdmVersion() -> VcdmVersion {
    return try!  FfiConverterTypeVcdmVersion.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_vcdm_version(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeJwtVc: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = JwtVc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> JwtVc {
        return JwtVc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: JwtVc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JwtVc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: JwtVc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeJwtVc_lift(_ pointer: UnsafeMutableRawPointer) throws -> JwtVc {
    return try FfiConverterTypeJwtVc.lift(pointer)
}

public func FfiConverterTypeJwtVc_lower(_ value: JwtVc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeJwtVc.lower(value)
}




public protocol MdlSessionManagerProtocol : AnyObject {
    
}

open class MdlSessionManager:
    MdlSessionManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_mdlsessionmanager(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_mdlsessionmanager(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeMDLSessionManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MdlSessionManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MdlSessionManager {
        return MdlSessionManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MdlSessionManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlSessionManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MdlSessionManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMDLSessionManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> MdlSessionManager {
    return try FfiConverterTypeMDLSessionManager.lift(pointer)
}

public func FfiConverterTypeMDLSessionManager_lower(_ value: MdlSessionManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMDLSessionManager.lower(value)
}




public protocol MdlPresentationSessionProtocol : AnyObject {
    
    /**
     * Constructs the response to be sent from the holder to the reader containing
     * the items of information the user has consented to share.
     *
     * Takes a HashMap of items the user has authorized the app to share, as well
     * as the id of a key stored in the key manager to be used to sign the response.
     * Returns a byte array containing the signed response to be returned to the
     * reader.
     */
    func generateResponse(permittedItems: [String: [String: [String]]]) throws  -> Data
    
    /**
     * Returns the BLE identification
     */
    func getBleIdent()  -> Data
    
    /**
     * Returns the generated QR code
     */
    func getQrCodeUri()  -> String
    
    /**
     * Handle a request from a reader that is seeking information from the mDL holder.
     *
     * Takes the raw bytes received from the reader by the holder over the transmission
     * technology. Returns a Vector of information items requested by the reader, or an
     * error.
     */
    func handleRequest(request: Data) throws  -> [ItemsRequest]
    
    func submitResponse(derSignature: Data) throws  -> Data
    
    /**
     * Terminates the mDL exchange session.
     *
     * Returns the termination message to be transmitted to the reader.
     */
    func terminateSession() throws  -> Data
    
}

open class MdlPresentationSession:
    MdlPresentationSessionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_mdlpresentationsession(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_mdlpresentationsession(pointer, $0) }
    }

    

    
    /**
     * Constructs the response to be sent from the holder to the reader containing
     * the items of information the user has consented to share.
     *
     * Takes a HashMap of items the user has authorized the app to share, as well
     * as the id of a key stored in the key manager to be used to sign the response.
     * Returns a byte array containing the signed response to be returned to the
     * reader.
     */
open func generateResponse(permittedItems: [String: [String: [String]]])throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSignatureError.lift) {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_generate_response(self.uniffiClonePointer(),
        FfiConverterDictionaryStringDictionaryStringSequenceString.lower(permittedItems),$0
    )
})
}
    
    /**
     * Returns the BLE identification
     */
open func getBleIdent() -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_get_ble_ident(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the generated QR code
     */
open func getQrCodeUri() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_get_qr_code_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Handle a request from a reader that is seeking information from the mDL holder.
     *
     * Takes the raw bytes received from the reader by the holder over the transmission
     * technology. Returns a Vector of information items requested by the reader, or an
     * error.
     */
open func handleRequest(request: Data)throws  -> [ItemsRequest] {
    return try  FfiConverterSequenceTypeItemsRequest.lift(try rustCallWithError(FfiConverterTypeRequestError.lift) {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_handle_request(self.uniffiClonePointer(),
        FfiConverterData.lower(request),$0
    )
})
}
    
open func submitResponse(derSignature: Data)throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSignatureError.lift) {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_submit_response(self.uniffiClonePointer(),
        FfiConverterData.lower(derSignature),$0
    )
})
}
    
    /**
     * Terminates the mDL exchange session.
     *
     * Returns the termination message to be transmitted to the reader.
     */
open func terminateSession()throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeTerminationError.lift) {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_terminate_session(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeMdlPresentationSession: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MdlPresentationSession

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MdlPresentationSession {
        return MdlPresentationSession(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MdlPresentationSession) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlPresentationSession {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MdlPresentationSession, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMdlPresentationSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> MdlPresentationSession {
    return try FfiConverterTypeMdlPresentationSession.lift(pointer)
}

public func FfiConverterTypeMdlPresentationSession_lower(_ value: MdlPresentationSession) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMdlPresentationSession.lower(value)
}




public protocol MdocProtocol : AnyObject {
    
    /**
     * Simple representation of mdoc namespace and data elements for display in the UI.
     */
    func details()  -> [Namespace: [Element]]
    
    /**
     * The document type of this mdoc, for example `org.iso.18013.5.1.mDL`.
     */
    func doctype()  -> String
    
    /**
     * The local ID of this credential.
     */
    func id()  -> Uuid
    
    func keyAlias()  -> KeyAlias
    
}

open class Mdoc:
    MdocProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_mdoc(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_mdoc(pointer, $0) }
    }

    
    /**
     * Construct a SpruceKit MDoc from a cbor-encoded
     * [spruceid/isomdl `Document`](https://github.com/spruceid/isomdl/blob/main/src/presentation/device.rs#L145-L152)
     */
public static func fromCborEncodedDocument(cborEncodedDocument: Data, keyAlias: KeyAlias)throws  -> Mdoc {
    return try  FfiConverterTypeMdoc.lift(try rustCallWithError(FfiConverterTypeMdocInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_mdoc_from_cbor_encoded_document(
        FfiConverterData.lower(cborEncodedDocument),
        FfiConverterTypeKeyAlias.lower(keyAlias),$0
    )
})
}
    
    /**
     * Compatibility feature: construct an MDoc from a
     * [stringified spruceid/isomdl `Document`](https://github.com/spruceid/isomdl/blob/main/src/presentation/mod.rs#L100)
     */
public static func fromStringifiedDocument(stringifiedDocument: String, keyAlias: KeyAlias)throws  -> Mdoc {
    return try  FfiConverterTypeMdoc.lift(try rustCallWithError(FfiConverterTypeMdocInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_mdoc_from_stringified_document(
        FfiConverterString.lower(stringifiedDocument),
        FfiConverterTypeKeyAlias.lower(keyAlias),$0
    )
})
}
    
    /**
     * Construct a new MDoc from base64url-encoded IssuerSigned.
     */
public static func newFromBase64urlEncodedIssuerSigned(base64urlEncodedIssuerSigned: String, keyAlias: KeyAlias)throws  -> Mdoc {
    return try  FfiConverterTypeMdoc.lift(try rustCallWithError(FfiConverterTypeMdocInitError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_mdoc_new_from_base64url_encoded_issuer_signed(
        FfiConverterString.lower(base64urlEncodedIssuerSigned),
        FfiConverterTypeKeyAlias.lower(keyAlias),$0
    )
})
}
    

    
    /**
     * Simple representation of mdoc namespace and data elements for display in the UI.
     */
open func details() -> [Namespace: [Element]] {
    return try!  FfiConverterDictionaryTypeNamespaceSequenceTypeElement.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdoc_details(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The document type of this mdoc, for example `org.iso.18013.5.1.mDL`.
     */
open func doctype() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdoc_doctype(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The local ID of this credential.
     */
open func id() -> Uuid {
    return try!  FfiConverterTypeUuid.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdoc_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func keyAlias() -> KeyAlias {
    return try!  FfiConverterTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdoc_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeMdoc: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Mdoc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Mdoc {
        return Mdoc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Mdoc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mdoc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Mdoc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMdoc_lift(_ pointer: UnsafeMutableRawPointer) throws -> Mdoc {
    return try FfiConverterTypeMdoc.lift(pointer)
}

public func FfiConverterTypeMdoc_lower(_ value: Mdoc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMdoc.lower(value)
}




public protocol Oid4vciProtocol : AnyObject {
    
    func exchangeCredential(proofsOfPossession: [String]) async throws  -> [CredentialResponse]
    
    func exchangeToken() async throws  -> String?
    
    func getMetadata() throws  -> Oid4vciMetadata
    
    func initiate(baseUrl: String, clientId: String, redirectUrl: String) async throws 
    
    func initiateWithOffer(credentialOffer: String, clientId: String, redirectUrl: String) async throws 
    
}

open class Oid4vci:
    Oid4vciProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_oid4vci(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_oid4vci(pointer, $0) }
    }

    
public static func newWithAsyncClient(client: AsyncHttpClient) -> Oid4vci {
    return try!  FfiConverterTypeOid4vci.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new_with_async_client(
        FfiConverterTypeAsyncHttpClient.lower(client),$0
    )
})
}
    
public static func newWithDefaultAsyncClient() -> Oid4vci {
    return try!  FfiConverterTypeOid4vci.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new_with_default_async_client($0
    )
})
}
    
public static func newWithDefaultSyncClient() -> Oid4vci {
    return try!  FfiConverterTypeOid4vci.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new_with_default_sync_client($0
    )
})
}
    
public static func newWithSyncClient(client: SyncHttpClient) -> Oid4vci {
    return try!  FfiConverterTypeOid4vci.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new_with_sync_client(
        FfiConverterTypeSyncHttpClient.lower(client),$0
    )
})
}
    

    
open func exchangeCredential(proofsOfPossession: [String])async throws  -> [CredentialResponse] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vci_exchange_credential(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(proofsOfPossession)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeCredentialResponse.lift,
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
    
open func exchangeToken()async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vci_exchange_token(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
    
open func getMetadata()throws  -> Oid4vciMetadata {
    return try  FfiConverterTypeOid4vciMetadata.lift(try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_method_oid4vci_get_metadata(self.uniffiClonePointer(),$0
    )
})
}
    
open func initiate(baseUrl: String, clientId: String, redirectUrl: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vci_initiate(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(baseUrl),FfiConverterString.lower(clientId),FfiConverterString.lower(redirectUrl)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
    
open func initiateWithOffer(credentialOffer: String, clientId: String, redirectUrl: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vci_initiate_with_offer(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(credentialOffer),FfiConverterString.lower(clientId),FfiConverterString.lower(redirectUrl)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
    

}

public struct FfiConverterTypeOid4vci: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Oid4vci

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vci {
        return Oid4vci(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Oid4vci) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vci {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Oid4vci, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOid4vci_lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vci {
    return try FfiConverterTypeOid4vci.lift(pointer)
}

public func FfiConverterTypeOid4vci_lower(_ value: Oid4vci) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOid4vci.lower(value)
}




public protocol Oid4vciMetadataProtocol : AnyObject {
    
    func authorizationServers()  -> [String]?
    
    func batchCredentialEndpoint()  -> String?
    
    func credentialEndpoint()  -> String
    
    func deferredCredentialEndpoint()  -> String?
    
    func issuer()  -> String
    
    func notificationEndpoint()  -> String?
    
    func toJson() throws  -> String
    
}

open class Oid4vciMetadata:
    Oid4vciMetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_oid4vcimetadata(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_oid4vcimetadata(pointer, $0) }
    }

    

    
open func authorizationServers() -> [String]? {
    return try!  FfiConverterOptionSequenceString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_authorization_servers(self.uniffiClonePointer(),$0
    )
})
}
    
open func batchCredentialEndpoint() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_batch_credential_endpoint(self.uniffiClonePointer(),$0
    )
})
}
    
open func credentialEndpoint() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_credential_endpoint(self.uniffiClonePointer(),$0
    )
})
}
    
open func deferredCredentialEndpoint() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_deferred_credential_endpoint(self.uniffiClonePointer(),$0
    )
})
}
    
open func issuer() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_issuer(self.uniffiClonePointer(),$0
    )
})
}
    
open func notificationEndpoint() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_notification_endpoint(self.uniffiClonePointer(),$0
    )
})
}
    
open func toJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_to_json(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeOid4vciMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Oid4vciMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vciMetadata {
        return Oid4vciMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Oid4vciMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vciMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Oid4vciMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOid4vciMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vciMetadata {
    return try FfiConverterTypeOid4vciMetadata.lift(pointer)
}

public func FfiConverterTypeOid4vciMetadata_lower(_ value: Oid4vciMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOid4vciMetadata.lower(value)
}




public protocol Oid4vciSessionProtocol : AnyObject {
    
    func getAllCredentialRequests() throws  -> [CredentialRequest]
    
    func getCredentialRequestByIndex(index: UInt16) throws  -> CredentialRequest
    
}

open class Oid4vciSession:
    Oid4vciSessionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_oid4vcisession(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_oid4vcisession(pointer, $0) }
    }

    

    
open func getAllCredentialRequests()throws  -> [CredentialRequest] {
    return try  FfiConverterSequenceTypeCredentialRequest.lift(try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_method_oid4vcisession_get_all_credential_requests(self.uniffiClonePointer(),$0
    )
})
}
    
open func getCredentialRequestByIndex(index: UInt16)throws  -> CredentialRequest {
    return try  FfiConverterTypeCredentialRequest.lift(try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_method_oid4vcisession_get_credential_request_by_index(self.uniffiClonePointer(),
        FfiConverterUInt16.lower(index),$0
    )
})
}
    

}

public struct FfiConverterTypeOid4vciSession: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Oid4vciSession

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vciSession {
        return Oid4vciSession(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Oid4vciSession) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vciSession {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Oid4vciSession, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOid4vciSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vciSession {
    return try FfiConverterTypeOid4vciSession.lift(pointer)
}

public func FfiConverterTypeOid4vciSession_lower(_ value: Oid4vciSession) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOid4vciSession.lower(value)
}




/**
 * A credential that has been parsed as a known variant.
 */
public protocol ParsedCredentialProtocol : AnyObject {
    
    /**
     * Convert a parsed credential into the generic form for storage.
     */
    func intoGenericForm() throws  -> Credential
    
}

/**
 * A credential that has been parsed as a known variant.
 */
open class ParsedCredential:
    ParsedCredentialProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_parsedcredential(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_parsedcredential(pointer, $0) }
    }

    
    /**
     * Construct a new `jwt_vc_json` credential.
     */
public static func newJwtVcJson(jwtVc: JwtVc) -> ParsedCredential {
    return try!  FfiConverterTypeParsedCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_jwt_vc_json(
        FfiConverterTypeJwtVc.lower(jwtVc),$0
    )
})
}
    
    /**
     * Construct a new `jwt_vc_json-ld` credential.
     */
public static func newJwtVcJsonLd(jwtVc: JwtVc) -> ParsedCredential {
    return try!  FfiConverterTypeParsedCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_jwt_vc_json_ld(
        FfiConverterTypeJwtVc.lower(jwtVc),$0
    )
})
}
    
    /**
     * Construct a new `ldp_vc` credential.
     */
public static func newLdpVc(jsonVc: JsonVc) -> ParsedCredential {
    return try!  FfiConverterTypeParsedCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_ldp_vc(
        FfiConverterTypeJsonVc.lower(jsonVc),$0
    )
})
}
    
    /**
     * Construct a new `mso_mdoc` credential.
     */
public static func newMsoMdoc(mdoc: Mdoc) -> ParsedCredential {
    return try!  FfiConverterTypeParsedCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_mso_mdoc(
        FfiConverterTypeMdoc.lower(mdoc),$0
    )
})
}
    
    /**
     * Parse a credential from the generic form retrieved from storage.
     */
public static func parseFromCredential(credential: Credential)throws  -> ParsedCredential {
    return try  FfiConverterTypeParsedCredential.lift(try rustCallWithError(FfiConverterTypeCredentialDecodingError.lift) {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_parse_from_credential(
        FfiConverterTypeCredential.lower(credential),$0
    )
})
}
    

    
    /**
     * Convert a parsed credential into the generic form for storage.
     */
open func intoGenericForm()throws  -> Credential {
    return try  FfiConverterTypeCredential.lift(try rustCallWithError(FfiConverterTypeCredentialEncodingError.lift) {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_into_generic_form(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeParsedCredential: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ParsedCredential

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ParsedCredential {
        return ParsedCredential(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ParsedCredential) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsedCredential {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ParsedCredential, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeParsedCredential_lift(_ pointer: UnsafeMutableRawPointer) throws -> ParsedCredential {
    return try FfiConverterTypeParsedCredential.lift(pointer)
}

public func FfiConverterTypeParsedCredential_lower(_ value: ParsedCredential) -> UnsafeMutableRawPointer {
    return FfiConverterTypeParsedCredential.lower(value)
}




/**
 * Interface: StorageManagerInterface
 *
 * The StorageManagerInterface provides access to functions defined in Kotlin and Swift for
 * managing persistent storage on the device.
 *
 * When dealing with UniFFI exported functions and objects, this will need to be Boxed as:
 * Box<dyn StorageManagerInterface>
 *
 * We use the older callback_interface to keep the required version level of our Android API
 * low.
 */
public protocol StorageManagerInterface : AnyObject {
    
    /**
     * Function: add
     *
     * Adds a key-value pair to storage.  Should the key already exist, the value will be
     * replaced
     *
     * Arguments:
     * key - The key to add
     * value - The value to add under the key.
     */
    func add(key: Key, value: Value) async throws 
    
    /**
     * Function: get
     *
     * Callback function pointer to native (kotlin/swift) code for
     * getting a key.
     */
    func get(key: Key) async throws  -> Value?
    
    /**
     * Function: list
     *
     * Callback function pointer for listing available keys.
     */
    func list() async throws  -> [Key]
    
    /**
     * Function: remove
     *
     * Callback function pointer to native (kotlin/swift) code for
     * removing a key.  This referenced function MUST be idempotent.  In
     * particular, it must treat removing a non-existent key as a normal and
     * expected circumstance, simply returning () and not an error.
     */
    func remove(key: Key) async throws 
    
}

/**
 * Interface: StorageManagerInterface
 *
 * The StorageManagerInterface provides access to functions defined in Kotlin and Swift for
 * managing persistent storage on the device.
 *
 * When dealing with UniFFI exported functions and objects, this will need to be Boxed as:
 * Box<dyn StorageManagerInterface>
 *
 * We use the older callback_interface to keep the required version level of our Android API
 * low.
 */
open class StorageManagerInterfaceImpl:
    StorageManagerInterface {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_storagemanagerinterface(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_storagemanagerinterface(pointer, $0) }
    }

    

    
    /**
     * Function: add
     *
     * Adds a key-value pair to storage.  Should the key already exist, the value will be
     * replaced
     *
     * Arguments:
     * key - The key to add
     * value - The value to add under the key.
     */
open func add(key: Key, value: Value)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_storagemanagerinterface_add(
                    self.uniffiClonePointer(),
                    FfiConverterTypeKey.lower(key),FfiConverterTypeValue.lower(value)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageManagerError.lift
        )
}
    
    /**
     * Function: get
     *
     * Callback function pointer to native (kotlin/swift) code for
     * getting a key.
     */
open func get(key: Key)async throws  -> Value? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_storagemanagerinterface_get(
                    self.uniffiClonePointer(),
                    FfiConverterTypeKey.lower(key)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeValue.lift,
            errorHandler: FfiConverterTypeStorageManagerError.lift
        )
}
    
    /**
     * Function: list
     *
     * Callback function pointer for listing available keys.
     */
open func list()async throws  -> [Key] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_storagemanagerinterface_list(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeKey.lift,
            errorHandler: FfiConverterTypeStorageManagerError.lift
        )
}
    
    /**
     * Function: remove
     *
     * Callback function pointer to native (kotlin/swift) code for
     * removing a key.  This referenced function MUST be idempotent.  In
     * particular, it must treat removing a non-existent key as a normal and
     * expected circumstance, simply returning () and not an error.
     */
open func remove(key: Key)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_storagemanagerinterface_remove(
                    self.uniffiClonePointer(),
                    FfiConverterTypeKey.lower(key)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageManagerError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceStorageManagerInterface {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceStorageManagerInterface = UniffiVTableCallbackInterfaceStorageManagerInterface(
        add: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            value: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorageManagerInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.add(
                     key: try FfiConverterTypeKey.lift(key),
                     value: try FfiConverterTypeValue.lift(value)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageManagerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        get: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Value? in
                guard let uniffiObj = try? FfiConverterTypeStorageManagerInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.get(
                     key: try FfiConverterTypeKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Value?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeValue.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageManagerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        list: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Key] in
                guard let uniffiObj = try? FfiConverterTypeStorageManagerInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.list(
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Key]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeKey.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageManagerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        remove: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorageManagerInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.remove(
                     key: try FfiConverterTypeKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageManagerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeStorageManagerInterface.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface StorageManagerInterface: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitStorageManagerInterface() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_storagemanagerinterface(&UniffiCallbackInterfaceStorageManagerInterface.vtable)
}

public struct FfiConverterTypeStorageManagerInterface: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<StorageManagerInterface>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = StorageManagerInterface

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> StorageManagerInterface {
        return StorageManagerInterfaceImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: StorageManagerInterface) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageManagerInterface {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: StorageManagerInterface, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeStorageManagerInterface_lift(_ pointer: UnsafeMutableRawPointer) throws -> StorageManagerInterface {
    return try FfiConverterTypeStorageManagerInterface.lift(pointer)
}

public func FfiConverterTypeStorageManagerInterface_lower(_ value: StorageManagerInterface) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStorageManagerInterface.lower(value)
}




public protocol SyncHttpClient : AnyObject {
    
    func httpClient(request: HttpRequest) throws  -> HttpResponse
    
}

open class SyncHttpClientImpl:
    SyncHttpClient {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_synchttpclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_synchttpclient(pointer, $0) }
    }

    

    
open func httpClient(request: HttpRequest)throws  -> HttpResponse {
    return try  FfiConverterTypeHttpResponse.lift(try rustCallWithError(FfiConverterTypeHttpClientError.lift) {
    uniffi_mobile_sdk_rs_fn_method_synchttpclient_http_client(self.uniffiClonePointer(),
        FfiConverterTypeHttpRequest.lower(request),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSyncHttpClient {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSyncHttpClient = UniffiVTableCallbackInterfaceSyncHttpClient(
        httpClient: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> HttpResponse in
                guard let uniffiObj = try? FfiConverterTypeSyncHttpClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.httpClient(
                     request: try FfiConverterTypeHttpRequest.lift(request)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeHttpResponse.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeHttpClientError.lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeSyncHttpClient.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SyncHttpClient: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSyncHttpClient() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_synchttpclient(&UniffiCallbackInterfaceSyncHttpClient.vtable)
}

public struct FfiConverterTypeSyncHttpClient: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<SyncHttpClient>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncHttpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncHttpClient {
        return SyncHttpClientImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncHttpClient) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncHttpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncHttpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSyncHttpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncHttpClient {
    return try FfiConverterTypeSyncHttpClient.lift(pointer)
}

public func FfiConverterTypeSyncHttpClient_lower(_ value: SyncHttpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncHttpClient.lower(value)
}




public protocol TokenResponseProtocol : AnyObject {
    
}

open class TokenResponse:
    TokenResponseProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_tokenresponse(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_tokenresponse(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeTokenResponse: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TokenResponse

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TokenResponse {
        return TokenResponse(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TokenResponse) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenResponse {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TokenResponse, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTokenResponse_lift(_ pointer: UnsafeMutableRawPointer) throws -> TokenResponse {
    return try FfiConverterTypeTokenResponse.lift(pointer)
}

public func FfiConverterTypeTokenResponse_lower(_ value: TokenResponse) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTokenResponse.lower(value)
}




/**
 * Verifiable Digital Credential Collection
 *
 * This is the main interface to credentials.
 */
public protocol VdcCollectionProtocol : AnyObject {
    
    /**
     * Add a credential to the set.
     */
    func add(credential: Credential) async throws 
    
    /**
     * Get a list of all the credentials.
     */
    func allEntries() async throws  -> [Uuid]
    
    /**
     * Get a list of all the credentials that match a specified type.
     */
    func allEntriesByType(ctype: CredentialType) async throws  -> [Uuid]
    
    /**
     * Remove a credential from the store.
     */
    func delete(id: Uuid) async throws 
    
    /**
     * Dump the contents of the credential set to the logger.
     */
    func dump() async 
    
    /**
     * Get a credential from the store.
     */
    func get(id: Uuid) async throws  -> Credential?
    
}

/**
 * Verifiable Digital Credential Collection
 *
 * This is the main interface to credentials.
 */
open class VdcCollection:
    VdcCollectionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_vdccollection(self.pointer, $0) }
    }
    /**
     * Create a new credential set.
     */
public convenience init(engine: StorageManagerInterface) {
    let pointer =
        try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_vdccollection_new(
        FfiConverterTypeStorageManagerInterface.lower(engine),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_vdccollection(pointer, $0) }
    }

    

    
    /**
     * Add a credential to the set.
     */
open func add(credential: Credential)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vdccollection_add(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCredential.lower(credential)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVdcCollectionError.lift
        )
}
    
    /**
     * Get a list of all the credentials.
     */
open func allEntries()async throws  -> [Uuid] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vdccollection_all_entries(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUuid.lift,
            errorHandler: FfiConverterTypeVdcCollectionError.lift
        )
}
    
    /**
     * Get a list of all the credentials that match a specified type.
     */
open func allEntriesByType(ctype: CredentialType)async throws  -> [Uuid] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vdccollection_all_entries_by_type(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCredentialType.lower(ctype)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUuid.lift,
            errorHandler: FfiConverterTypeVdcCollectionError.lift
        )
}
    
    /**
     * Remove a credential from the store.
     */
open func delete(id: Uuid)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vdccollection_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUuid.lower(id)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVdcCollectionError.lift
        )
}
    
    /**
     * Dump the contents of the credential set to the logger.
     */
open func dump()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vdccollection_dump(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Get a credential from the store.
     */
open func get(id: Uuid)async throws  -> Credential? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vdccollection_get(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUuid.lower(id)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeCredential.lift,
            errorHandler: FfiConverterTypeVdcCollectionError.lift
        )
}
    

}

public struct FfiConverterTypeVdcCollection: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = VdcCollection

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> VdcCollection {
        return VdcCollection(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: VdcCollection) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VdcCollection {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: VdcCollection, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeVdcCollection_lift(_ pointer: UnsafeMutableRawPointer) throws -> VdcCollection {
    return try FfiConverterTypeVdcCollection.lift(pointer)
}

public func FfiConverterTypeVdcCollection_lower(_ value: VdcCollection) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVdcCollection.lower(value)
}


/**
 * An unparsed credential, retrieved from storage.
 */
public struct Credential {
    /**
     * The local ID of this credential.
     */
    public var id: Uuid
    /**
     * The format of this credential.
     */
    public var format: CredentialFormat
    /**
     * The type of this credential.
     */
    public var type: CredentialType
    /**
     * The raw payload of this credential. The encoding depends on the format.
     */
    public var payload: Data
    /**
     * The alias of the key that is authorized to present this credential.
     */
    public var keyAlias: KeyAlias?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The local ID of this credential.
         */id: Uuid, 
        /**
         * The format of this credential.
         */format: CredentialFormat, 
        /**
         * The type of this credential.
         */type: CredentialType, 
        /**
         * The raw payload of this credential. The encoding depends on the format.
         */payload: Data, 
        /**
         * The alias of the key that is authorized to present this credential.
         */keyAlias: KeyAlias?) {
        self.id = id
        self.format = format
        self.type = type
        self.payload = payload
        self.keyAlias = keyAlias
    }
}



extension Credential: Equatable, Hashable {
    public static func ==(lhs: Credential, rhs: Credential) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.format != rhs.format {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.payload != rhs.payload {
            return false
        }
        if lhs.keyAlias != rhs.keyAlias {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(format)
        hasher.combine(type)
        hasher.combine(payload)
        hasher.combine(keyAlias)
    }
}


public struct FfiConverterTypeCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Credential {
        return
            try Credential(
                id: FfiConverterTypeUuid.read(from: &buf), 
                format: FfiConverterTypeCredentialFormat.read(from: &buf), 
                type: FfiConverterTypeCredentialType.read(from: &buf), 
                payload: FfiConverterData.read(from: &buf), 
                keyAlias: FfiConverterOptionTypeKeyAlias.read(from: &buf)
        )
    }

    public static func write(_ value: Credential, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeCredentialFormat.write(value.format, into: &buf)
        FfiConverterTypeCredentialType.write(value.type, into: &buf)
        FfiConverterData.write(value.payload, into: &buf)
        FfiConverterOptionTypeKeyAlias.write(value.keyAlias, into: &buf)
    }
}


public func FfiConverterTypeCredential_lift(_ buf: RustBuffer) throws -> Credential {
    return try FfiConverterTypeCredential.lift(buf)
}

public func FfiConverterTypeCredential_lower(_ value: Credential) -> RustBuffer {
    return FfiConverterTypeCredential.lower(value)
}


/**
 * Information about the verified credential.
 */
public struct CredentialInfo {
    /**
     * The credential title that should be displayed on the success screen.
     */
    public var title: String
    /**
     * The image that should be displayed on the success screen.
     */
    public var image: Data
    /**
     * The claims decoded from the credential.
     */
    public var claims: [String: ClaimValue]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The credential title that should be displayed on the success screen.
         */title: String, 
        /**
         * The image that should be displayed on the success screen.
         */image: Data, 
        /**
         * The claims decoded from the credential.
         */claims: [String: ClaimValue]) {
        self.title = title
        self.image = image
        self.claims = claims
    }
}



extension CredentialInfo: Equatable, Hashable {
    public static func ==(lhs: CredentialInfo, rhs: CredentialInfo) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.image != rhs.image {
            return false
        }
        if lhs.claims != rhs.claims {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(image)
        hasher.combine(claims)
    }
}


public struct FfiConverterTypeCredentialInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialInfo {
        return
            try CredentialInfo(
                title: FfiConverterString.read(from: &buf), 
                image: FfiConverterData.read(from: &buf), 
                claims: FfiConverterDictionaryStringTypeClaimValue.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterData.write(value.image, into: &buf)
        FfiConverterDictionaryStringTypeClaimValue.write(value.claims, into: &buf)
    }
}


public func FfiConverterTypeCredentialInfo_lift(_ buf: RustBuffer) throws -> CredentialInfo {
    return try FfiConverterTypeCredentialInfo.lift(buf)
}

public func FfiConverterTypeCredentialInfo_lower(_ value: CredentialInfo) -> RustBuffer {
    return FfiConverterTypeCredentialInfo.lower(value)
}


public struct CredentialResponse {
    public var format: CredentialFormat
    public var payload: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(format: CredentialFormat, payload: Data) {
        self.format = format
        self.payload = payload
    }
}



extension CredentialResponse: Equatable, Hashable {
    public static func ==(lhs: CredentialResponse, rhs: CredentialResponse) -> Bool {
        if lhs.format != rhs.format {
            return false
        }
        if lhs.payload != rhs.payload {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(format)
        hasher.combine(payload)
    }
}


public struct FfiConverterTypeCredentialResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialResponse {
        return
            try CredentialResponse(
                format: FfiConverterTypeCredentialFormat.read(from: &buf), 
                payload: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialResponse, into buf: inout [UInt8]) {
        FfiConverterTypeCredentialFormat.write(value.format, into: &buf)
        FfiConverterData.write(value.payload, into: &buf)
    }
}


public func FfiConverterTypeCredentialResponse_lift(_ buf: RustBuffer) throws -> CredentialResponse {
    return try FfiConverterTypeCredentialResponse.lift(buf)
}

public func FfiConverterTypeCredentialResponse_lower(_ value: CredentialResponse) -> RustBuffer {
    return FfiConverterTypeCredentialResponse.lower(value)
}


/**
 * Simple representation of an mdoc data element.
 */
public struct Element {
    /**
     * Name of the data element.
     */
    public var identifier: String
    /**
     * JSON representation of the data element, missing if the value cannot be represented as JSON.
     */
    public var value: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Name of the data element.
         */identifier: String, 
        /**
         * JSON representation of the data element, missing if the value cannot be represented as JSON.
         */value: String?) {
        self.identifier = identifier
        self.value = value
    }
}



extension Element: Equatable, Hashable {
    public static func ==(lhs: Element, rhs: Element) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(value)
    }
}


public struct FfiConverterTypeElement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Element {
        return
            try Element(
                identifier: FfiConverterString.read(from: &buf), 
                value: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Element, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterOptionString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeElement_lift(_ buf: RustBuffer) throws -> Element {
    return try FfiConverterTypeElement.lift(buf)
}

public func FfiConverterTypeElement_lower(_ value: Element) -> RustBuffer {
    return FfiConverterTypeElement.lower(value)
}


/**
 * A verification failure with a code and reason.
 */
public struct Failure {
    public var code: UInt64
    public var reason: String
    public var details: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(code: UInt64, reason: String, details: String) {
        self.code = code
        self.reason = reason
        self.details = details
    }
}



extension Failure: Equatable, Hashable {
    public static func ==(lhs: Failure, rhs: Failure) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(reason)
        hasher.combine(details)
    }
}


public struct FfiConverterTypeFailure: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Failure {
        return
            try Failure(
                code: FfiConverterUInt64.read(from: &buf), 
                reason: FfiConverterString.read(from: &buf), 
                details: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Failure, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.code, into: &buf)
        FfiConverterString.write(value.reason, into: &buf)
        FfiConverterString.write(value.details, into: &buf)
    }
}


public func FfiConverterTypeFailure_lift(_ buf: RustBuffer) throws -> Failure {
    return try FfiConverterTypeFailure.lift(buf)
}

public func FfiConverterTypeFailure_lower(_ value: Failure) -> RustBuffer {
    return FfiConverterTypeFailure.lower(value)
}


/**
 * Plain Rust object representation of an HttpRequest that can be exported
 * through `uniffi` and is used in `WithForeign` trait definitions for HTTP
 * clients.
 */
public struct HttpRequest {
    public var url: String
    public var method: String
    public var headers: [String: String]
    public var body: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, method: String, headers: [String: String], body: Data) {
        self.url = url
        self.method = method
        self.headers = headers
        self.body = body
    }
}



extension HttpRequest: Equatable, Hashable {
    public static func ==(lhs: HttpRequest, rhs: HttpRequest) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(method)
        hasher.combine(headers)
        hasher.combine(body)
    }
}


public struct FfiConverterTypeHttpRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpRequest {
        return
            try HttpRequest(
                url: FfiConverterString.read(from: &buf), 
                method: FfiConverterString.read(from: &buf), 
                headers: FfiConverterDictionaryStringString.read(from: &buf), 
                body: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: HttpRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.method, into: &buf)
        FfiConverterDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterData.write(value.body, into: &buf)
    }
}


public func FfiConverterTypeHttpRequest_lift(_ buf: RustBuffer) throws -> HttpRequest {
    return try FfiConverterTypeHttpRequest.lift(buf)
}

public func FfiConverterTypeHttpRequest_lower(_ value: HttpRequest) -> RustBuffer {
    return FfiConverterTypeHttpRequest.lower(value)
}


/**
 * Plain Rust object representation of an HttpResponse that can be exported
 * through `uniffi` and is used in `WithForeign` trait definitions for HTTP
 * clients.
 */
public struct HttpResponse {
    public var statusCode: UInt16
    public var headers: [String: String]
    public var body: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(statusCode: UInt16, headers: [String: String], body: Data) {
        self.statusCode = statusCode
        self.headers = headers
        self.body = body
    }
}



extension HttpResponse: Equatable, Hashable {
    public static func ==(lhs: HttpResponse, rhs: HttpResponse) -> Bool {
        if lhs.statusCode != rhs.statusCode {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(statusCode)
        hasher.combine(headers)
        hasher.combine(body)
    }
}


public struct FfiConverterTypeHttpResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpResponse {
        return
            try HttpResponse(
                statusCode: FfiConverterUInt16.read(from: &buf), 
                headers: FfiConverterDictionaryStringString.read(from: &buf), 
                body: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: HttpResponse, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.statusCode, into: &buf)
        FfiConverterDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterData.write(value.body, into: &buf)
    }
}


public func FfiConverterTypeHttpResponse_lift(_ buf: RustBuffer) throws -> HttpResponse {
    return try FfiConverterTypeHttpResponse.lift(buf)
}

public func FfiConverterTypeHttpResponse_lower(_ value: HttpResponse) -> RustBuffer {
    return FfiConverterTypeHttpResponse.lower(value)
}


public struct ItemsRequest {
    public var docType: String
    public var namespaces: [String: [String: Bool]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(docType: String, namespaces: [String: [String: Bool]]) {
        self.docType = docType
        self.namespaces = namespaces
    }
}



extension ItemsRequest: Equatable, Hashable {
    public static func ==(lhs: ItemsRequest, rhs: ItemsRequest) -> Bool {
        if lhs.docType != rhs.docType {
            return false
        }
        if lhs.namespaces != rhs.namespaces {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(docType)
        hasher.combine(namespaces)
    }
}


public struct FfiConverterTypeItemsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ItemsRequest {
        return
            try ItemsRequest(
                docType: FfiConverterString.read(from: &buf), 
                namespaces: FfiConverterDictionaryStringDictionaryStringBool.read(from: &buf)
        )
    }

    public static func write(_ value: ItemsRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.docType, into: &buf)
        FfiConverterDictionaryStringDictionaryStringBool.write(value.namespaces, into: &buf)
    }
}


public func FfiConverterTypeItemsRequest_lift(_ buf: RustBuffer) throws -> ItemsRequest {
    return try FfiConverterTypeItemsRequest.lift(buf)
}

public func FfiConverterTypeItemsRequest_lower(_ value: ItemsRequest) -> RustBuffer {
    return FfiConverterTypeItemsRequest.lower(value)
}


public struct MdlReaderResponseData {
    public var state: MdlSessionManager
    /**
     * Contains the namespaces for the mDL directly, without top-level doc types
     */
    public var verifiedResponse: [String: [String: MDocItem]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: MdlSessionManager, 
        /**
         * Contains the namespaces for the mDL directly, without top-level doc types
         */verifiedResponse: [String: [String: MDocItem]]) {
        self.state = state
        self.verifiedResponse = verifiedResponse
    }
}



public struct FfiConverterTypeMDLReaderResponseData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderResponseData {
        return
            try MdlReaderResponseData(
                state: FfiConverterTypeMDLSessionManager.read(from: &buf), 
                verifiedResponse: FfiConverterDictionaryStringDictionaryStringTypeMDocItem.read(from: &buf)
        )
    }

    public static func write(_ value: MdlReaderResponseData, into buf: inout [UInt8]) {
        FfiConverterTypeMDLSessionManager.write(value.state, into: &buf)
        FfiConverterDictionaryStringDictionaryStringTypeMDocItem.write(value.verifiedResponse, into: &buf)
    }
}


public func FfiConverterTypeMDLReaderResponseData_lift(_ buf: RustBuffer) throws -> MdlReaderResponseData {
    return try FfiConverterTypeMDLReaderResponseData.lift(buf)
}

public func FfiConverterTypeMDLReaderResponseData_lower(_ value: MdlReaderResponseData) -> RustBuffer {
    return FfiConverterTypeMDLReaderResponseData.lower(value)
}


public struct MdlReaderSessionData {
    public var state: MdlSessionManager
    public var uuid: Uuid
    public var request: Data
    public var bleIdent: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: MdlSessionManager, uuid: Uuid, request: Data, bleIdent: Data) {
        self.state = state
        self.uuid = uuid
        self.request = request
        self.bleIdent = bleIdent
    }
}



public struct FfiConverterTypeMDLReaderSessionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderSessionData {
        return
            try MdlReaderSessionData(
                state: FfiConverterTypeMDLSessionManager.read(from: &buf), 
                uuid: FfiConverterTypeUuid.read(from: &buf), 
                request: FfiConverterData.read(from: &buf), 
                bleIdent: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: MdlReaderSessionData, into buf: inout [UInt8]) {
        FfiConverterTypeMDLSessionManager.write(value.state, into: &buf)
        FfiConverterTypeUuid.write(value.uuid, into: &buf)
        FfiConverterData.write(value.request, into: &buf)
        FfiConverterData.write(value.bleIdent, into: &buf)
    }
}


public func FfiConverterTypeMDLReaderSessionData_lift(_ buf: RustBuffer) throws -> MdlReaderSessionData {
    return try FfiConverterTypeMDLReaderSessionData.lift(buf)
}

public func FfiConverterTypeMDLReaderSessionData_lower(_ value: MdlReaderSessionData) -> RustBuffer {
    return FfiConverterTypeMDLReaderSessionData.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Credential claim values.
 */

public enum ClaimValue {
    
    /**
     * Any text claim that doesn't need special formatting.
     */
    case text(value: String
    )
    /**
     * A date claim in the format `[year]-[month]-[day]`.
     */
    case date(value: String
    )
    /**
     * MapArray
     */
    case mapClaim(value: [String: String]
    )
}


public struct FfiConverterTypeClaimValue: FfiConverterRustBuffer {
    typealias SwiftType = ClaimValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .date(value: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .mapClaim(value: try FfiConverterDictionaryStringString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClaimValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .date(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .mapClaim(value):
            writeInt(&buf, Int32(3))
            FfiConverterDictionaryStringString.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeClaimValue_lift(_ buf: RustBuffer) throws -> ClaimValue {
    return try FfiConverterTypeClaimValue.lift(buf)
}

public func FfiConverterTypeClaimValue_lower(_ value: ClaimValue) -> RustBuffer {
    return FfiConverterTypeClaimValue.lower(value)
}



extension ClaimValue: Equatable, Hashable {}




public enum CredentialDecodingError {

    
    
    case MsoMdoc(MdocInitError
    )
    case JsonVc(JsonVcInitError
    )
    case JwtVc(JwtVcInitError
    )
    case UnsupportedCredentialFormat
}


public struct FfiConverterTypeCredentialDecodingError: FfiConverterRustBuffer {
    typealias SwiftType = CredentialDecodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialDecodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MsoMdoc(
            try FfiConverterTypeMdocInitError.read(from: &buf)
            )
        case 2: return .JsonVc(
            try FfiConverterTypeJsonVcInitError.read(from: &buf)
            )
        case 3: return .JwtVc(
            try FfiConverterTypeJwtVcInitError.read(from: &buf)
            )
        case 4: return .UnsupportedCredentialFormat

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CredentialDecodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .MsoMdoc(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMdocInitError.write(v1, into: &buf)
            
        
        case let .JsonVc(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeJsonVcInitError.write(v1, into: &buf)
            
        
        case let .JwtVc(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeJwtVcInitError.write(v1, into: &buf)
            
        
        case .UnsupportedCredentialFormat:
            writeInt(&buf, Int32(4))
        
        }
    }
}


extension CredentialDecodingError: Equatable, Hashable {}

extension CredentialDecodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum CredentialEncodingError {

    
    
    case MsoMdoc(MdocEncodingError
    )
    case JsonVc(JsonVcEncodingError
    )
}


public struct FfiConverterTypeCredentialEncodingError: FfiConverterRustBuffer {
    typealias SwiftType = CredentialEncodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialEncodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MsoMdoc(
            try FfiConverterTypeMdocEncodingError.read(from: &buf)
            )
        case 2: return .JsonVc(
            try FfiConverterTypeJsonVcEncodingError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CredentialEncodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .MsoMdoc(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMdocEncodingError.write(v1, into: &buf)
            
        
        case let .JsonVc(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeJsonVcEncodingError.write(v1, into: &buf)
            
        }
    }
}


extension CredentialEncodingError: Equatable, Hashable {}

extension CredentialEncodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The format of the credential.
 */

public enum CredentialFormat {
    
    case msoMdoc
    case jwtVcJson
    case jwtVcJsonLd
    case ldpVc
    case other(String
    )
}


public struct FfiConverterTypeCredentialFormat: FfiConverterRustBuffer {
    typealias SwiftType = CredentialFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .msoMdoc
        
        case 2: return .jwtVcJson
        
        case 3: return .jwtVcJsonLd
        
        case 4: return .ldpVc
        
        case 5: return .other(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CredentialFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .msoMdoc:
            writeInt(&buf, Int32(1))
        
        
        case .jwtVcJson:
            writeInt(&buf, Int32(2))
        
        
        case .jwtVcJsonLd:
            writeInt(&buf, Int32(3))
        
        
        case .ldpVc:
            writeInt(&buf, Int32(4))
        
        
        case let .other(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeCredentialFormat_lift(_ buf: RustBuffer) throws -> CredentialFormat {
    return try FfiConverterTypeCredentialFormat.lift(buf)
}

public func FfiConverterTypeCredentialFormat_lower(_ value: CredentialFormat) -> RustBuffer {
    return FfiConverterTypeCredentialFormat.lower(value)
}



extension CredentialFormat: Equatable, Hashable {}




public enum HttpClientError {

    
    
    case RequestBuilder
    case ResponseBuilder
    case UrlParse
    case MethodParse
    case HeaderParse
    case HeaderKeyParse(key: String
    )
    case HeaderValueParse(value: String
    )
    case HeaderEntryParse(key: String, value: String
    )
    case Other(error: String
    )
}


public struct FfiConverterTypeHttpClientError: FfiConverterRustBuffer {
    typealias SwiftType = HttpClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RequestBuilder
        case 2: return .ResponseBuilder
        case 3: return .UrlParse
        case 4: return .MethodParse
        case 5: return .HeaderParse
        case 6: return .HeaderKeyParse(
            key: try FfiConverterString.read(from: &buf)
            )
        case 7: return .HeaderValueParse(
            value: try FfiConverterString.read(from: &buf)
            )
        case 8: return .HeaderEntryParse(
            key: try FfiConverterString.read(from: &buf), 
            value: try FfiConverterString.read(from: &buf)
            )
        case 9: return .Other(
            error: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HttpClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .RequestBuilder:
            writeInt(&buf, Int32(1))
        
        
        case .ResponseBuilder:
            writeInt(&buf, Int32(2))
        
        
        case .UrlParse:
            writeInt(&buf, Int32(3))
        
        
        case .MethodParse:
            writeInt(&buf, Int32(4))
        
        
        case .HeaderParse:
            writeInt(&buf, Int32(5))
        
        
        case let .HeaderKeyParse(key):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(key, into: &buf)
            
        
        case let .HeaderValueParse(value):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .HeaderEntryParse(key,value):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
            
        
        case let .Other(error):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


extension HttpClientError: Equatable, Hashable {}

extension HttpClientError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum JsonVcEncodingError {

    
    
    case JsonBytesEncoding
}


public struct FfiConverterTypeJsonVcEncodingError: FfiConverterRustBuffer {
    typealias SwiftType = JsonVcEncodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonVcEncodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .JsonBytesEncoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JsonVcEncodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .JsonBytesEncoding:
            writeInt(&buf, Int32(1))
        
        }
    }
}


extension JsonVcEncodingError: Equatable, Hashable {}

extension JsonVcEncodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum JsonVcInitError {

    
    
    case CredentialDecoding
    case CredentialStringEncoding
    case JsonBytesDecoding
    case JsonStringDecoding
}


public struct FfiConverterTypeJsonVcInitError: FfiConverterRustBuffer {
    typealias SwiftType = JsonVcInitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonVcInitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CredentialDecoding
        case 2: return .CredentialStringEncoding
        case 3: return .JsonBytesDecoding
        case 4: return .JsonStringDecoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JsonVcInitError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .CredentialDecoding:
            writeInt(&buf, Int32(1))
        
        
        case .CredentialStringEncoding:
            writeInt(&buf, Int32(2))
        
        
        case .JsonBytesDecoding:
            writeInt(&buf, Int32(3))
        
        
        case .JsonStringDecoding:
            writeInt(&buf, Int32(4))
        
        }
    }
}


extension JsonVcInitError: Equatable, Hashable {}

extension JsonVcInitError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum JwtVcInitError {

    
    
    case CompactJwsDecoding
    case CredentialClaimDecoding
    case CredentialClaimMissing
    case CredentialStringEncoding
    case JwsBytesDecoding
    case JwtDecoding
    case HeaderDecoding
    case PayloadDecoding
}


public struct FfiConverterTypeJwtVcInitError: FfiConverterRustBuffer {
    typealias SwiftType = JwtVcInitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JwtVcInitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CompactJwsDecoding
        case 2: return .CredentialClaimDecoding
        case 3: return .CredentialClaimMissing
        case 4: return .CredentialStringEncoding
        case 5: return .JwsBytesDecoding
        case 6: return .JwtDecoding
        case 7: return .HeaderDecoding
        case 8: return .PayloadDecoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JwtVcInitError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .CompactJwsDecoding:
            writeInt(&buf, Int32(1))
        
        
        case .CredentialClaimDecoding:
            writeInt(&buf, Int32(2))
        
        
        case .CredentialClaimMissing:
            writeInt(&buf, Int32(3))
        
        
        case .CredentialStringEncoding:
            writeInt(&buf, Int32(4))
        
        
        case .JwsBytesDecoding:
            writeInt(&buf, Int32(5))
        
        
        case .JwtDecoding:
            writeInt(&buf, Int32(6))
        
        
        case .HeaderDecoding:
            writeInt(&buf, Int32(7))
        
        
        case .PayloadDecoding:
            writeInt(&buf, Int32(8))
        
        }
    }
}


extension JwtVcInitError: Equatable, Hashable {}

extension JwtVcInitError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum KeyTransformationError {

    
    
    case ToPkcs8(value: String
    )
    case FromPkcs8(value: String
    )
    case FromSec1(value: String
    )
    case ToSec1(value: String
    )
}


public struct FfiConverterTypeKeyTransformationError: FfiConverterRustBuffer {
    typealias SwiftType = KeyTransformationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyTransformationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ToPkcs8(
            value: try FfiConverterString.read(from: &buf)
            )
        case 2: return .FromPkcs8(
            value: try FfiConverterString.read(from: &buf)
            )
        case 3: return .FromSec1(
            value: try FfiConverterString.read(from: &buf)
            )
        case 4: return .ToSec1(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeyTransformationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ToPkcs8(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .FromPkcs8(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .FromSec1(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .ToSec1(value):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension KeyTransformationError: Equatable, Hashable {}

extension KeyTransformationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum MdlReaderResponseError {

    
    
    case InvalidDecryption
    case InvalidParsing
    case InvalidIssuerAuthentication
    case InvalidDeviceAuthentication
    case Generic(value: String
    )
}


public struct FfiConverterTypeMDLReaderResponseError: FfiConverterRustBuffer {
    typealias SwiftType = MdlReaderResponseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderResponseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidDecryption
        case 2: return .InvalidParsing
        case 3: return .InvalidIssuerAuthentication
        case 4: return .InvalidDeviceAuthentication
        case 5: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdlReaderResponseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidDecryption:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidParsing:
            writeInt(&buf, Int32(2))
        
        
        case .InvalidIssuerAuthentication:
            writeInt(&buf, Int32(3))
        
        
        case .InvalidDeviceAuthentication:
            writeInt(&buf, Int32(4))
        
        
        case let .Generic(value):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension MdlReaderResponseError: Equatable, Hashable {}

extension MdlReaderResponseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum MdlReaderSessionError {

    
    
    case Generic(value: String
    )
}


public struct FfiConverterTypeMDLReaderSessionError: FfiConverterRustBuffer {
    typealias SwiftType = MdlReaderSessionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderSessionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdlReaderSessionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension MdlReaderSessionError: Equatable, Hashable {}

extension MdlReaderSessionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MDocItem {
    
    case text(String
    )
    case bool(Bool
    )
    case integer(Int64
    )
    case itemMap([String: MDocItem]
    )
    case array([MDocItem]
    )
}


public struct FfiConverterTypeMDocItem: FfiConverterRustBuffer {
    typealias SwiftType = MDocItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MDocItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .bool(try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .integer(try FfiConverterInt64.read(from: &buf)
        )
        
        case 4: return .itemMap(try FfiConverterDictionaryStringTypeMDocItem.read(from: &buf)
        )
        
        case 5: return .array(try FfiConverterSequenceTypeMDocItem.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MDocItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .bool(v1):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(v1, into: &buf)
            
        
        case let .integer(v1):
            writeInt(&buf, Int32(3))
            FfiConverterInt64.write(v1, into: &buf)
            
        
        case let .itemMap(v1):
            writeInt(&buf, Int32(4))
            FfiConverterDictionaryStringTypeMDocItem.write(v1, into: &buf)
            
        
        case let .array(v1):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeMDocItem.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMDocItem_lift(_ buf: RustBuffer) throws -> MDocItem {
    return try FfiConverterTypeMDocItem.lift(buf)
}

public func FfiConverterTypeMDocItem_lower(_ value: MDocItem) -> RustBuffer {
    return FfiConverterTypeMDocItem.lower(value)
}



extension MDocItem: Equatable, Hashable {}




public enum MdocEncodingError {

    
    
    case DocumentCborEncoding
}


public struct FfiConverterTypeMdocEncodingError: FfiConverterRustBuffer {
    typealias SwiftType = MdocEncodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdocEncodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DocumentCborEncoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdocEncodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .DocumentCborEncoding:
            writeInt(&buf, Int32(1))
        
        }
    }
}


extension MdocEncodingError: Equatable, Hashable {}

extension MdocEncodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum MdocInitError {

    
    
    case DocumentCborDecoding
    case IssuerSignedBase64UrlDecoding
    case IssuerSignedCborDecoding
    case IssuerAuthPayloadMissing
    case IssuerAuthPayloadDecoding
    case KeyAliasMissing
    case NamespacesMissing
    case DocumentUtf8Decoding
}


public struct FfiConverterTypeMdocInitError: FfiConverterRustBuffer {
    typealias SwiftType = MdocInitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdocInitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DocumentCborDecoding
        case 2: return .IssuerSignedBase64UrlDecoding
        case 3: return .IssuerSignedCborDecoding
        case 4: return .IssuerAuthPayloadMissing
        case 5: return .IssuerAuthPayloadDecoding
        case 6: return .KeyAliasMissing
        case 7: return .NamespacesMissing
        case 8: return .DocumentUtf8Decoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdocInitError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .DocumentCborDecoding:
            writeInt(&buf, Int32(1))
        
        
        case .IssuerSignedBase64UrlDecoding:
            writeInt(&buf, Int32(2))
        
        
        case .IssuerSignedCborDecoding:
            writeInt(&buf, Int32(3))
        
        
        case .IssuerAuthPayloadMissing:
            writeInt(&buf, Int32(4))
        
        
        case .IssuerAuthPayloadDecoding:
            writeInt(&buf, Int32(5))
        
        
        case .KeyAliasMissing:
            writeInt(&buf, Int32(6))
        
        
        case .NamespacesMissing:
            writeInt(&buf, Int32(7))
        
        
        case .DocumentUtf8Decoding:
            writeInt(&buf, Int32(8))
        
        }
    }
}


extension MdocInitError: Equatable, Hashable {}

extension MdocInitError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum Oid4vciError {

    
    
    case SerdeJsonError(message: String)
    
    case RequestError(message: String)
    
    case UnsupportedGrantType(message: String)
    
    case InvalidSession(message: String)
    
    case InvalidParameter(message: String)
    
    case LockError(message: String)
    
    case Generic(message: String)
    
}


public struct FfiConverterTypeOid4vciError: FfiConverterRustBuffer {
    typealias SwiftType = Oid4vciError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vciError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SerdeJsonError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .RequestError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .UnsupportedGrantType(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidSession(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidParameter(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .LockError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Oid4vciError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .SerdeJsonError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .RequestError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .UnsupportedGrantType(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .InvalidSession(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvalidParameter(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .LockError(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))

        
        }
    }
}


extension Oid4vciError: Equatable, Hashable {}

extension Oid4vciError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The outcome of attempting to verify a credential.
 */

public enum Outcome {
    
    /**
     * The credential was successfully verified.
     */
    case verified(credentialInfo: CredentialInfo
    )
    /**
     * The credential could not be verified.
     */
    case unverified(credentialInfo: CredentialInfo?, failure: Failure
    )
}


public struct FfiConverterTypeOutcome: FfiConverterRustBuffer {
    typealias SwiftType = Outcome

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Outcome {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .verified(credentialInfo: try FfiConverterTypeCredentialInfo.read(from: &buf)
        )
        
        case 2: return .unverified(credentialInfo: try FfiConverterOptionTypeCredentialInfo.read(from: &buf), failure: try FfiConverterTypeFailure.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Outcome, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .verified(credentialInfo):
            writeInt(&buf, Int32(1))
            FfiConverterTypeCredentialInfo.write(credentialInfo, into: &buf)
            
        
        case let .unverified(credentialInfo,failure):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeCredentialInfo.write(credentialInfo, into: &buf)
            FfiConverterTypeFailure.write(failure, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOutcome_lift(_ buf: RustBuffer) throws -> Outcome {
    return try FfiConverterTypeOutcome.lift(buf)
}

public func FfiConverterTypeOutcome_lower(_ value: Outcome) -> RustBuffer {
    return FfiConverterTypeOutcome.lower(value)
}



extension Outcome: Equatable, Hashable {}




public enum RequestError {

    
    
    case Generic(value: String
    )
}


public struct FfiConverterTypeRequestError: FfiConverterRustBuffer {
    typealias SwiftType = RequestError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension RequestError: Equatable, Hashable {}

extension RequestError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum ResponseError {

    
    
    case MissingSignature
    case Generic(value: String
    )
}


public struct FfiConverterTypeResponseError: FfiConverterRustBuffer {
    typealias SwiftType = ResponseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResponseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingSignature
        case 2: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResponseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .MissingSignature:
            writeInt(&buf, Int32(1))
        
        
        case let .Generic(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension ResponseError: Equatable, Hashable {}

extension ResponseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum SdJwtVcError {

    
    
    case JwtDecoding
    case InvalidSdJwt
    case Serialization
}


public struct FfiConverterTypeSdJwtVcError: FfiConverterRustBuffer {
    typealias SwiftType = SdJwtVcError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdJwtVcError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .JwtDecoding
        case 2: return .InvalidSdJwt
        case 3: return .Serialization

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdJwtVcError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .JwtDecoding:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidSdJwt:
            writeInt(&buf, Int32(2))
        
        
        case .Serialization:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension SdJwtVcError: Equatable, Hashable {}

extension SdJwtVcError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum SessionError {

    
    
    case Generic(value: String
    )
}


public struct FfiConverterTypeSessionError: FfiConverterRustBuffer {
    typealias SwiftType = SessionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SessionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension SessionError: Equatable, Hashable {}

extension SessionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum SignatureError {

    
    
    case InvalidSignature(value: String
    )
    case TooManyDocuments
    case Generic(value: String
    )
}


public struct FfiConverterTypeSignatureError: FfiConverterRustBuffer {
    typealias SwiftType = SignatureError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidSignature(
            value: try FfiConverterString.read(from: &buf)
            )
        case 2: return .TooManyDocuments
        case 3: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidSignature(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case .TooManyDocuments:
            writeInt(&buf, Int32(2))
        
        
        case let .Generic(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension SignatureError: Equatable, Hashable {}

extension SignatureError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


/**
 * Enum: StorageManagerError
 *
 * Represents errors that may occur during storage management operations
 */
public enum StorageManagerError {

    
    
    /**
     * This error happens when the key value could not be used with the underlying
     * storage system on the device
     */
    case InvalidLookupKey
    /**
     * This error occurrs when we can retrieve a value, but could not decrypt it
     */
    case CouldNotDecryptValue
    /**
     * The underlying device has no more storage available
     */
    case StorageFull
    /**
     * During storage manager initialization, it must create a new encryption key.  This
     * error is raised when that key could not be created.
     */
    case CouldNotMakeKey
    /**
     * An internal problem occurred in the storage manager.
     */
    case InternalError
}


public struct FfiConverterTypeStorageManagerError: FfiConverterRustBuffer {
    typealias SwiftType = StorageManagerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageManagerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidLookupKey
        case 2: return .CouldNotDecryptValue
        case 3: return .StorageFull
        case 4: return .CouldNotMakeKey
        case 5: return .InternalError

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StorageManagerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidLookupKey:
            writeInt(&buf, Int32(1))
        
        
        case .CouldNotDecryptValue:
            writeInt(&buf, Int32(2))
        
        
        case .StorageFull:
            writeInt(&buf, Int32(3))
        
        
        case .CouldNotMakeKey:
            writeInt(&buf, Int32(4))
        
        
        case .InternalError:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension StorageManagerError: Equatable, Hashable {}

extension StorageManagerError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum TerminationError {

    
    
    case Generic(value: String
    )
}


public struct FfiConverterTypeTerminationError: FfiConverterRustBuffer {
    typealias SwiftType = TerminationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TerminationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TerminationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension TerminationError: Equatable, Hashable {}

extension TerminationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum VcbVerificationError {

    
    
    case Generic(value: String
    )
    case Verification
}


public struct FfiConverterTypeVCBVerificationError: FfiConverterRustBuffer {
    typealias SwiftType = VcbVerificationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VcbVerificationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Verification

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VcbVerificationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case .Verification:
            writeInt(&buf, Int32(2))
        
        }
    }
}


extension VcbVerificationError: Equatable, Hashable {}

extension VcbVerificationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum VcVerificationError {

    
    
    case Generic(value: String
    )
}


public struct FfiConverterTypeVCVerificationError: FfiConverterRustBuffer {
    typealias SwiftType = VcVerificationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VcVerificationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VcVerificationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension VcVerificationError: Equatable, Hashable {}

extension VcVerificationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum VpError {

    
    
    case Verification
    case Signing
    case Parsing(value: String
    )
    case Generic(value: String
    )
}


public struct FfiConverterTypeVPError: FfiConverterRustBuffer {
    typealias SwiftType = VpError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VpError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Verification
        case 2: return .Signing
        case 3: return .Parsing(
            value: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VpError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Verification:
            writeInt(&buf, Int32(1))
        
        
        case .Signing:
            writeInt(&buf, Int32(2))
        
        
        case let .Parsing(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .Generic(value):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


extension VpError: Equatable, Hashable {}

extension VpError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VcdmVersion {
    
    case v1
    case v2
}


public struct FfiConverterTypeVcdmVersion: FfiConverterRustBuffer {
    typealias SwiftType = VcdmVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VcdmVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v1
        
        case 2: return .v2
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VcdmVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v1:
            writeInt(&buf, Int32(1))
        
        
        case .v2:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeVcdmVersion_lift(_ buf: RustBuffer) throws -> VcdmVersion {
    return try FfiConverterTypeVcdmVersion.lift(buf)
}

public func FfiConverterTypeVcdmVersion_lower(_ value: VcdmVersion) -> RustBuffer {
    return FfiConverterTypeVcdmVersion.lower(value)
}



extension VcdmVersion: Equatable, Hashable {}




public enum VdcCollectionError {

    
    
    /**
     * Attempt to convert the credential to a serialized form suitable for writing to storage failed.
     */
    case SerializeFailed
    /**
     * Attempting to convert the credential to a deserialized form suitable for runtime use failed.
     */
    case DeserializeFailed
    /**
     * Attempting to write the credential to storage failed.
     */
    case StoreFailed(StorageManagerError
    )
    /**
     * Attempting to read the credential from storage failed.
     */
    case LoadFailed(StorageManagerError
    )
    /**
     * Attempting to delete a credential from storage failed.
     */
    case DeleteFailed(StorageManagerError
    )
}


public struct FfiConverterTypeVdcCollectionError: FfiConverterRustBuffer {
    typealias SwiftType = VdcCollectionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VdcCollectionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SerializeFailed
        case 2: return .DeserializeFailed
        case 3: return .StoreFailed(
            try FfiConverterTypeStorageManagerError.read(from: &buf)
            )
        case 4: return .LoadFailed(
            try FfiConverterTypeStorageManagerError.read(from: &buf)
            )
        case 5: return .DeleteFailed(
            try FfiConverterTypeStorageManagerError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VdcCollectionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .SerializeFailed:
            writeInt(&buf, Int32(1))
        
        
        case .DeserializeFailed:
            writeInt(&buf, Int32(2))
        
        
        case let .StoreFailed(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeStorageManagerError.write(v1, into: &buf)
            
        
        case let .LoadFailed(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeStorageManagerError.write(v1, into: &buf)
            
        
        case let .DeleteFailed(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeStorageManagerError.write(v1, into: &buf)
            
        }
    }
}


extension VdcCollectionError: Equatable, Hashable {}

extension VdcCollectionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VerificationResult {
    
    case success
    case failure(cause: String
    )
}


public struct FfiConverterTypeVerificationResult: FfiConverterRustBuffer {
    typealias SwiftType = VerificationResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerificationResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .success
        
        case 2: return .failure(cause: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerificationResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case .success:
            writeInt(&buf, Int32(1))
        
        
        case let .failure(cause):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(cause, into: &buf)
            
        }
    }
}


public func FfiConverterTypeVerificationResult_lift(_ buf: RustBuffer) throws -> VerificationResult {
    return try FfiConverterTypeVerificationResult.lift(buf)
}

public func FfiConverterTypeVerificationResult_lower(_ value: VerificationResult) -> RustBuffer {
    return FfiConverterTypeVerificationResult.lower(value)
}



extension VerificationResult: Equatable, Hashable {}



fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCredential: FfiConverterRustBuffer {
    typealias SwiftType = Credential?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCredential.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCredential.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCredentialInfo: FfiConverterRustBuffer {
    typealias SwiftType = CredentialInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCredentialInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCredentialInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeKeyAlias: FfiConverterRustBuffer {
    typealias SwiftType = KeyAlias?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeKeyAlias.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeKeyAlias.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeValue: FfiConverterRustBuffer {
    typealias SwiftType = Value?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCredentialRequest: FfiConverterRustBuffer {
    typealias SwiftType = [CredentialRequest]

    public static func write(_ value: [CredentialRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCredentialRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CredentialRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [CredentialRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCredentialRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCredentialResponse: FfiConverterRustBuffer {
    typealias SwiftType = [CredentialResponse]

    public static func write(_ value: [CredentialResponse], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCredentialResponse.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CredentialResponse] {
        let len: Int32 = try readInt(&buf)
        var seq = [CredentialResponse]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCredentialResponse.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeElement: FfiConverterRustBuffer {
    typealias SwiftType = [Element]

    public static func write(_ value: [Element], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeElement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Element] {
        let len: Int32 = try readInt(&buf)
        var seq = [Element]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeElement.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeItemsRequest: FfiConverterRustBuffer {
    typealias SwiftType = [ItemsRequest]

    public static func write(_ value: [ItemsRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeItemsRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ItemsRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [ItemsRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeItemsRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMDocItem: FfiConverterRustBuffer {
    typealias SwiftType = [MDocItem]

    public static func write(_ value: [MDocItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMDocItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MDocItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [MDocItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMDocItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeKey: FfiConverterRustBuffer {
    typealias SwiftType = [Key]

    public static func write(_ value: [Key], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Key] {
        let len: Int32 = try readInt(&buf)
        var seq = [Key]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUuid: FfiConverterRustBuffer {
    typealias SwiftType = [Uuid]

    public static func write(_ value: [Uuid], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUuid.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Uuid] {
        let len: Int32 = try readInt(&buf)
        var seq = [Uuid]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUuid.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringBool: FfiConverterRustBuffer {
    public static func write(_ value: [String: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeClaimValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: ClaimValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeClaimValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ClaimValue] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ClaimValue]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeClaimValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeMDocItem: FfiConverterRustBuffer {
    public static func write(_ value: [String: MDocItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeMDocItem.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: MDocItem] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: MDocItem]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeMDocItem.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringBool: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: Bool]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: Bool]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: Bool]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringTypeMDocItem: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: MDocItem]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringTypeMDocItem.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: MDocItem]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: MDocItem]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringTypeMDocItem.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: [String]]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: [String]]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: [String]]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeNamespaceSequenceTypeElement: FfiConverterRustBuffer {
    public static func write(_ value: [Namespace: [Element]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeNamespace.write(key, into: &buf)
            FfiConverterSequenceTypeElement.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Namespace: [Element]] {
        let len: Int32 = try readInt(&buf)
        var dict = [Namespace: [Element]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeNamespace.read(from: &buf)
            let value = try FfiConverterSequenceTypeElement.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias CredentialType = String
public struct FfiConverterTypeCredentialType: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialType {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: CredentialType, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> CredentialType {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: CredentialType) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeCredentialType_lift(_ value: RustBuffer) throws -> CredentialType {
    return try FfiConverterTypeCredentialType.lift(value)
}

public func FfiConverterTypeCredentialType_lower(_ value: CredentialType) -> RustBuffer {
    return FfiConverterTypeCredentialType.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Key = String
public struct FfiConverterTypeKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Key {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Key, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Key {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Key) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeKey_lift(_ value: RustBuffer) throws -> Key {
    return try FfiConverterTypeKey.lift(value)
}

public func FfiConverterTypeKey_lower(_ value: Key) -> RustBuffer {
    return FfiConverterTypeKey.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias KeyAlias = String
public struct FfiConverterTypeKeyAlias: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyAlias {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: KeyAlias, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> KeyAlias {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: KeyAlias) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeKeyAlias_lift(_ value: RustBuffer) throws -> KeyAlias {
    return try FfiConverterTypeKeyAlias.lift(value)
}

public func FfiConverterTypeKeyAlias_lower(_ value: KeyAlias) -> RustBuffer {
    return FfiConverterTypeKeyAlias.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Namespace = String
public struct FfiConverterTypeNamespace: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Namespace {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Namespace, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Namespace {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Namespace) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeNamespace_lift(_ value: RustBuffer) throws -> Namespace {
    return try FfiConverterTypeNamespace.lift(value)
}

public func FfiConverterTypeNamespace_lower(_ value: Namespace) -> RustBuffer {
    return FfiConverterTypeNamespace.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Uuid = String
public struct FfiConverterTypeUuid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Uuid, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Uuid {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Uuid) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeUuid_lift(_ value: RustBuffer) throws -> Uuid {
    return try FfiConverterTypeUuid.lift(value)
}

public func FfiConverterTypeUuid_lower(_ value: Uuid) -> RustBuffer {
    return FfiConverterTypeUuid.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Value = Data
public struct FfiConverterTypeValue: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Value {
        return try FfiConverterData.read(from: &buf)
    }

    public static func write(_ value: Value, into buf: inout [UInt8]) {
        return FfiConverterData.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Value {
        return try FfiConverterData.lift(value)
    }

    public static func lower(_ value: Value) -> RustBuffer {
        return FfiConverterData.lower(value)
    }
}


public func FfiConverterTypeValue_lift(_ value: RustBuffer) throws -> Value {
    return try FfiConverterTypeValue.lift(value)
}

public func FfiConverterTypeValue_lower(_ value: Value) -> RustBuffer {
    return FfiConverterTypeValue.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountMobileSdkRs() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
public func decodeRevealSdJwt(input: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeSdJwtVcError.lift) {
    uniffi_mobile_sdk_rs_fn_func_decode_reveal_sd_jwt(
        FfiConverterString.lower(input),$0
    )
})
}
public func establishSession(uri: String, requestedItems: [String: [String: Bool]], trustAnchorRegistry: [String]?)throws  -> MdlReaderSessionData {
    return try  FfiConverterTypeMDLReaderSessionData.lift(try rustCallWithError(FfiConverterTypeMDLReaderSessionError.lift) {
    uniffi_mobile_sdk_rs_fn_func_establish_session(
        FfiConverterString.lower(uri),
        FfiConverterDictionaryStringDictionaryStringBool.lower(requestedItems),
        FfiConverterOptionSequenceString.lower(trustAnchorRegistry),$0
    )
})
}
public func generatePopComplete(signingInput: Data, signature: Data)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_func_generate_pop_complete(
        FfiConverterData.lower(signingInput),
        FfiConverterData.lower(signature),$0
    )
})
}
public func generatePopPrepare(audience: String, issuer: String, nonce: String?, vm: String, publicJwk: String, durationInSecs: Int64?)throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_func_generate_pop_prepare(
        FfiConverterString.lower(audience),
        FfiConverterString.lower(issuer),
        FfiConverterOptionString.lower(nonce),
        FfiConverterString.lower(vm),
        FfiConverterString.lower(publicJwk),
        FfiConverterOptionInt64.lower(durationInSecs),$0
    )
})
}
public func handleResponse(state: MdlSessionManager, response: Data)throws  -> MdlReaderResponseData {
    return try  FfiConverterTypeMDLReaderResponseData.lift(try rustCallWithError(FfiConverterTypeMDLReaderResponseError.lift) {
    uniffi_mobile_sdk_rs_fn_func_handle_response(
        FfiConverterTypeMDLSessionManager.lower(state),
        FfiConverterData.lower(response),$0
    )
})
}
/**
 * Begin the mDL presentation process for the holder when the desired
 * Mdoc is already stored in a [VdcCollection].
 *
 * Initializes the presentation session for an ISO 18013-5 mDL and stores
 * the session state object in the device storage_manager.
 *
 * Arguments:
 * mdoc_id: unique identifier for the credential to present, to be looked up
 * in the VDC collection
 * uuid:    the Bluetooth Low Energy Client Central Mode UUID to be used
 *
 * Returns:
 * A Result, with the `Ok` containing a tuple consisting of an enum representing
 * the state of the presentation, a String containing the QR code URI, and a
 * String containing the BLE ident.

 */
public func initializeMdlPresentation(mdocId: Uuid, uuid: Uuid, storageManager: StorageManagerInterface)async throws  -> MdlPresentationSession {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_initialize_mdl_presentation(FfiConverterTypeUuid.lower(mdocId),FfiConverterTypeUuid.lower(uuid),FfiConverterTypeStorageManagerInterface.lower(storageManager)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeMdlPresentationSession.lift,
            errorHandler: FfiConverterTypeSessionError.lift
        )
}
/**
 * Begin the mDL presentation process for the holder by passing in the credential
 * to be presented in the form of an [Mdoc] object.
 *
 * Initializes the presentation session for an ISO 18013-5 mDL and stores
 * the session state object in the device storage_manager.
 *
 * Arguments:
 * mdoc: the Mdoc to be presented, as an [Mdoc] object
 * uuid: the Bluetooth Low Energy Client Central Mode UUID to be used
 *
 * Returns:
 * A Result, with the `Ok` containing a tuple consisting of an enum representing
 * the state of the presentation, a String containing the QR code URI, and a
 * String containing the BLE ident.

 */
public func initializeMdlPresentationFromBytes(mdocBytes: Data, keyAlias: KeyAlias, uuid: Uuid)async throws  -> MdlPresentationSession {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_initialize_mdl_presentation_from_bytes(FfiConverterData.lower(mdocBytes),FfiConverterTypeKeyAlias.lower(keyAlias),FfiConverterTypeUuid.lower(uuid)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeMdlPresentationSession.lift,
            errorHandler: FfiConverterTypeSessionError.lift
        )
}
public func oid4vciExchangeCredential(session: Oid4vciSession, proofsOfPossession: [String], httpClient: IHttpClient)async throws  -> [CredentialResponse] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_oid4vci_exchange_credential(FfiConverterTypeOid4vciSession.lower(session),FfiConverterSequenceString.lower(proofsOfPossession),FfiConverterTypeIHttpClient.lower(httpClient)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeCredentialResponse.lift,
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
public func oid4vciExchangeToken(session: Oid4vciSession, httpClient: IHttpClient)async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_oid4vci_exchange_token(FfiConverterTypeOid4vciSession.lower(session),FfiConverterTypeIHttpClient.lower(httpClient)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
public func oid4vciGetMetadata(session: Oid4vciSession)throws  -> Oid4vciMetadata {
    return try  FfiConverterTypeOid4vciMetadata.lift(try rustCallWithError(FfiConverterTypeOid4vciError.lift) {
    uniffi_mobile_sdk_rs_fn_func_oid4vci_get_metadata(
        FfiConverterTypeOid4vciSession.lower(session),$0
    )
})
}
public func oid4vciInitiate(baseUrl: String, clientId: String, redirectUrl: String, httpClient: IHttpClient)async throws  -> Oid4vciSession {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_oid4vci_initiate(FfiConverterString.lower(baseUrl),FfiConverterString.lower(clientId),FfiConverterString.lower(redirectUrl),FfiConverterTypeIHttpClient.lower(httpClient)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeOid4vciSession.lift,
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
public func oid4vciInitiateWithOffer(credentialOffer: String, clientId: String, redirectUrl: String, httpClient: IHttpClient)async throws  -> Oid4vciSession {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_oid4vci_initiate_with_offer(FfiConverterString.lower(credentialOffer),FfiConverterString.lower(clientId),FfiConverterString.lower(redirectUrl),FfiConverterTypeIHttpClient.lower(httpClient)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeOid4vciSession.lift,
            errorHandler: FfiConverterTypeOid4vciError.lift
        )
}
public func vcToSignedVp(vc: String, keyStr: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_vc_to_signed_vp(FfiConverterString.lower(vc),FfiConverterString.lower(keyStr)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeVPError.lift
        )
}
public func verifyJsonVcString(json: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_verify_json_vc_string(FfiConverterString.lower(json)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVCVerificationError.lift
        )
}
public func verifyJwtVp(jwtVp: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_verify_jwt_vp(FfiConverterString.lower(jwtVp)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVPError.lift
        )
}
public func verifyPdf417Barcode(payload: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_verify_pdf417_barcode(FfiConverterString.lower(payload)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVCBVerificationError.lift
        )
}
public func verifyVcbQrcodeAgainstMrz(mrzPayload: String, qrPayload: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_verify_vcb_qrcode_against_mrz(FfiConverterString.lower(mrzPayload),FfiConverterString.lower(qrPayload)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVCBVerificationError.lift
        )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_mobile_sdk_rs_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_decode_reveal_sd_jwt() != 24154) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_establish_session() != 26937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_generate_pop_complete() != 56778) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_generate_pop_prepare() != 18468) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_handle_response() != 43961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_initialize_mdl_presentation() != 29387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_initialize_mdl_presentation_from_bytes() != 64088) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_exchange_credential() != 13827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_exchange_token() != 3394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_get_metadata() != 16967) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_initiate() != 45435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_initiate_with_offer() != 12958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_vc_to_signed_vp() != 47312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verify_json_vc_string() != 13072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verify_jwt_vp() != 8825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verify_pdf417_barcode() != 14164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verify_vcb_qrcode_against_mrz() != 36527) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_asynchttpclient_http_client() != 44924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_credential_as_json_encoded_utf8_string() != 36585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_id() != 12139) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_key_alias() != 36306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_type() != 48063) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_types() != 3171) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_vcdm_version() != 26490) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_credential_as_json_encoded_utf8_string() != 41803) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_id() != 55448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_jws_header_as_json_encoded_utf8_string() != 46211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_jws_payload_as_json_encoded_utf8_string() != 6252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_key_alias() != 13659) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_type() != 41101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_types() != 60467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_vcdm_version() != 26158) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_generate_response() != 37013) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_get_ble_ident() != 25991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_get_qr_code_uri() != 36281) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_handle_request() != 21650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_submit_response() != 684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_terminate_session() != 8677) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdoc_details() != 29355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdoc_doctype() != 46465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdoc_id() != 18877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdoc_key_alias() != 39341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_exchange_credential() != 17336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_exchange_token() != 35585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_get_metadata() != 38460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_initiate() != 12704) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_initiate_with_offer() != 23294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_authorization_servers() != 42340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_batch_credential_endpoint() != 60237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_credential_endpoint() != 16138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_deferred_credential_endpoint() != 24938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_issuer() != 28727) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_notification_endpoint() != 39275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_to_json() != 52469) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcisession_get_all_credential_requests() != 32094) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcisession_get_credential_request_by_index() != 55077) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_into_generic_form() != 30318) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_storagemanagerinterface_add() != 39162) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_storagemanagerinterface_get() != 35430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_storagemanagerinterface_list() != 37678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_storagemanagerinterface_remove() != 24982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_synchttpclient_http_client() != 53085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_add() != 42040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_all_entries() != 7074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_all_entries_by_type() != 232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_delete() != 63691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_dump() != 37372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_get() != 1085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_ihttpclient_new_async() != 55307) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_ihttpclient_new_sync() != 47576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jsonvc_new_from_json() != 40674) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jsonvc_new_from_json_with_key() != 63463) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jwtvc_new_from_compact_jws() != 5193) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jwtvc_new_from_compact_jws_with_key() != 27338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_mdoc_from_cbor_encoded_document() != 32979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_mdoc_from_stringified_document() != 58042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_mdoc_new_from_base64url_encoded_issuer_signed() != 17520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new() != 27200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new_with_async_client() != 57260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new_with_default_async_client() != 51040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new_with_default_sync_client() != 30492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new_with_sync_client() != 31928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_jwt_vc_json() != 56340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_jwt_vc_json_ld() != 46832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_ldp_vc() != 45177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_mso_mdoc() != 58058) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_parse_from_credential() != 15018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_vdccollection_new() != 31236) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitAsyncHttpClient()
    uniffiCallbackInitStorageManagerInterface()
    uniffiCallbackInitSyncHttpClient()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all